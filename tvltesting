-- ‚ö° ANTI-DUPLICATE EXECUTION CHECK ‚ö°
if _G.TVL_SCRIPT_LOADED then
    warn('[SCRIPT] Script is already running! Execution blocked.')
    return
end
_G.TVL_SCRIPT_LOADED = true
print('[SCRIPT] First execution detected, loading script...')

-- ‚ö° HARDWARE ID WHITELIST SYSTEM ‚ö°
local whitelistUrl =
    'https://raw.githubusercontent.com/velsonly/PublicScripts/refs/heads/main/Whitelist2'

-- Get executor HWID
local function getHWID()
    local hwid = nil
    local method = 'unknown'

    -- Try different executor HWID methods (in order of preference)
    if gethwid then
        hwid = gethwid()
        method = 'gethwid'
    elseif syn and syn.fingerprint then
        hwid = syn.fingerprint()
        method = 'syn.fingerprint'
    elseif getexecutoridentifier then
        hwid = getexecutoridentifier()
        method = 'getexecutoridentifier'
    elseif identifyexecutor then
        local executor = identifyexecutor()
        if executor then
            hwid = executor
                .. '_'
                .. game:GetService('Players').LocalPlayer.UserId
            method = 'identifyexecutor'
        end
    end

    if hwid then
        print('[WHITELIST] HWID Method: ' .. method)
        print('[WHITELIST] Raw HWID: ' .. tostring(hwid))
    end

    return hwid
end

-- Fetch whitelist from GitHub
local function fetchWhitelist()
    local success, result = pcall(function()
        return game:HttpGet(whitelistUrl)
    end)

    if not success then
        warn('[WHITELIST] Failed to fetch whitelist: ' .. tostring(result))
        return nil
    end

    -- Parse the whitelist (it's a Lua table)
    local whitelistFunc, err = loadstring(result)
    if not whitelistFunc then
        warn('[WHITELIST] Failed to parse whitelist: ' .. tostring(err))
        return nil
    end

    local whitelistTable = whitelistFunc()
    return whitelistTable
end

-- Check if HWID is whitelisted
local function isWhitelisted(hwid, whitelist)
    if not hwid or not whitelist then
        return false
    end

    for _, whitelistedHWID in ipairs(whitelist) do
        if hwid == whitelistedHWID then
            return true
        end
    end

    return false
end

-- Main whitelist check
print('[WHITELIST] Checking authorization...')
local userHWID = getHWID()

if not userHWID then
    game:GetService('Players').LocalPlayer
        :Kick('‚ùå Failed to get HWID. Executor not supported.')
    return
end

print('[WHITELIST] Your HWID: ' .. userHWID)

local whitelist = fetchWhitelist()
if not whitelist then
    game:GetService('Players').LocalPlayer
        :Kick('‚ùå Failed to fetch whitelist. Try again later.')
    return
end

if not isWhitelisted(userHWID, whitelist) then
    -- Copy HWID to clipboard before kicking
    if setclipboard then
        setclipboard(userHWID)
        print('[WHITELIST] HWID copied to clipboard!')
    elseif toclipboard then
        toclipboard(userHWID)
        print('[WHITELIST] HWID copied to clipboard!')
    end

    game:GetService('Players').LocalPlayer:Kick(
        '‚ùå Access Denied\n\nYour HWID is not whitelisted.\nHWID: '
            .. userHWID
            .. '\n\n(HWID copied to clipboard)'
    )
    return
end

print('[WHITELIST] ‚úÖ Authorization successful!')

-- ‚ö° WEBHOOK LOGGING SYSTEM ‚ö°
local WEBHOOK_URL =
    'https://discord.com/api/webhooks/1430275075369861181/CGUF4TZQ24eJB4Xun38BDSJvA4i9US2PDie9YS42vljOxFfjuLTj7s_LMah4CTnhaSCM' -- Replace with your Discord webhook URL

local function sendWebhookLog()
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer
    local HttpService = game:GetService('HttpService')

    print('[WEBHOOK] Starting webhook log...')

    -- Detect request function with multiple fallbacks
    local requestFunc = nil
    local requestMethod = 'unknown'

    -- Try all possible request function names
    if syn and syn.request then
        requestFunc = syn.request
        requestMethod = 'syn.request'
    elseif request then
        requestFunc = request
        requestMethod = 'request'
    elseif http_request then
        requestFunc = http_request
        requestMethod = 'http_request'
    elseif http and http.request then
        requestFunc = http.request
        requestMethod = 'http.request'
    elseif fluxus and fluxus.request then
        requestFunc = fluxus.request
        requestMethod = 'fluxus.request'
    end

    if not requestFunc then
        warn('[WEBHOOK] ‚ùå No request function available - webhook disabled')
        return
    end

    print('[WEBHOOK] Using request method: ' .. requestMethod)

    -- Gather execution data
    local executionData = {
        username = LocalPlayer.Name,
        displayName = LocalPlayer.DisplayName,
        userId = LocalPlayer.UserId,
        hwid = userHWID,
        executor = identifyexecutor and identifyexecutor() or 'Unknown',
        timestamp = os.date('%Y-%m-%d %H:%M:%S'),
        gameName = 'Loading...',
        gameId = game.PlaceId,
        jobId = game.JobId,
    }

    -- Try to get game name
    pcall(function()
        executionData.gameName = game:GetService('MarketplaceService')
            :GetProductInfo(game.PlaceId).Name
    end)

    -- Create Discord embed
    local embed = {
        ['title'] = 'üöÄ Script Executed',
        ['color'] = 3066993, -- Green color
        ['fields'] = {
            {
                ['name'] = 'üë§ User',
                ['value'] = string.format(
                    '%s (@%s)',
                    executionData.displayName,
                    executionData.username
                ),
                ['inline'] = true,
            },
            {
                ['name'] = 'üÜî User ID',
                ['value'] = tostring(executionData.userId),
                ['inline'] = true,
            },
            {
                ['name'] = 'üîë HWID',
                ['value'] = '```' .. executionData.hwid .. '```',
                ['inline'] = false,
            },
            {
                ['name'] = '‚öôÔ∏è Executor',
                ['value'] = executionData.executor,
                ['inline'] = true,
            },
            {
                ['name'] = 'üïê Timestamp',
                ['value'] = executionData.timestamp,
                ['inline'] = true,
            },
            {
                ['name'] = 'üéÆ Game',
                ['value'] = executionData.gameName,
                ['inline'] = false,
            },
            {
                ['name'] = 'üîó Game ID',
                ['value'] = tostring(executionData.gameId),
                ['inline'] = true,
            },
            {
                ['name'] = 'üåê Job ID',
                ['value'] = executionData.jobId,
                ['inline'] = true,
            },
        },
        ['footer'] = {
            ['text'] = 'Script Execution Logger',
        },
        ['timestamp'] = os.date('!%Y-%m-%dT%H:%M:%S'),
    }

    local payload = HttpService:JSONEncode({
        ['embeds'] = { embed },
    })

    print('[WEBHOOK] Payload created, sending...')

    -- Send webhook (use spawn to avoid blocking script execution)
    task.spawn(function()
        local success, err = pcall(function()
            local response = requestFunc({
                Url = WEBHOOK_URL,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json',
                },
                Body = payload,
            })

            if
                response
                and (response.StatusCode == 200 or response.StatusCode == 204)
            then
                print('[WEBHOOK] ‚úÖ Execution logged successfully')
            elseif response then
                warn(
                    '[WEBHOOK] ‚ö†Ô∏è Failed to log: Status '
                        .. tostring(response.StatusCode)
                )
            else
                warn('[WEBHOOK] ‚ö†Ô∏è No response received')
            end
        end)

        if not success then
            warn('[WEBHOOK] ‚ùå Error sending webhook: ' .. tostring(err))
        end
    end)
end

-- Send webhook log (completely non-blocking)
task.spawn(function()
    pcall(function()
        if WEBHOOK_URL ~= 'YOUR_DISCORD_WEBHOOK_URL_HERE' then
            sendWebhookLog()
        else
            warn('[WEBHOOK] ‚ö†Ô∏è Webhook URL not configured')
        end
    end)
end)

-- Wait for game to be fully loaded before executing anything
if not game:IsLoaded() then
    print('[SCRIPT] Waiting for game to load...')
    game.Loaded:Wait()
end

-- Additional wait to ensure all services are ready
task.wait(0.05)
print('[SCRIPT] Game loaded, initializing GUI...')

-- Global initialization flag - prevents ALL interactions until ready
_G.__SCRIPT_FULLY_INITIALIZED = false

-- Load Fluent with error handling
local Fluent, SaveManager, InterfaceManager

local success, err = pcall(function()
    print('[SCRIPT] Loading Fluent UI library...')
    local fluentCode = game:HttpGet(
        'https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua'
    )
    Fluent = loadstring(fluentCode)()
    print('[SCRIPT] Fluent loaded successfully')
end)

if not success then
    warn('[SCRIPT] Failed to load Fluent: ' .. tostring(err))
    game:GetService('Players').LocalPlayer:Kick(
        '‚ùå GUI Library Failed to Load\n\nError: '
            .. tostring(err)
            .. '\n\nTry again or contact support.'
    )
    return
end

success, err = pcall(function()
    print('[SCRIPT] Loading SaveManager...')
    local saveCode = game:HttpGet(
        'https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua'
    )
    SaveManager = loadstring(saveCode)()
    print('[SCRIPT] SaveManager loaded successfully')
end)

if not success then
    warn('[SCRIPT] Failed to load SaveManager: ' .. tostring(err))
    game:GetService('Players').LocalPlayer:Kick(
        '‚ùå SaveManager Failed to Load\n\nError: '
            .. tostring(err)
            .. '\n\nTry again or contact support.'
    )
    return
end

success, err = pcall(function()
    print('[SCRIPT] Loading InterfaceManager...')
    local interfaceCode = game:HttpGet(
        'https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua'
    )
    InterfaceManager = loadstring(interfaceCode)()
    print('[SCRIPT] InterfaceManager loaded successfully')
end)

if not success then
    warn('[SCRIPT] Failed to load InterfaceManager: ' .. tostring(err))
    game:GetService('Players').LocalPlayer:Kick(
        '‚ùå InterfaceManager Failed to Load\n\nError: '
            .. tostring(err)
            .. '\n\nTry again or contact support.'
    )
    return
end

local Window = Fluent:CreateWindow({
    Title = 'The Vampire Legends 2',
    SubTitle = 'By Vel',
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = 'Dark',
    MinimizeKey = Enum.KeyCode.K, -- Default keybind, will be overridden by Settings
})

local Options = Fluent.Options

-- Set script as initialized immediately - auto deploy will handle its own checks
_G.__SCRIPT_FULLY_INITIALIZED = true
print('[SCRIPT] Script initialized - all features ready')

-- Helper function to wrap callbacks with initialization check
local function SafeCallback(callback)
    return function(...)
        if not _G.__SCRIPT_FULLY_INITIALIZED then
            Fluent:Notify({
                Title = 'Please Wait',
                Content = 'Script is still initializing...',
                Duration = 1.5,
            })
            return
        end
        return callback(...)
    end
end

-- AUTODEPLOY REINIT ON 'J' IN LOBBY
do
    local UserInputService = game:GetService('UserInputService')
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer

    local function isInLobby()
        local ok, inLobby = pcall(function()
            local pg = LocalPlayer:FindFirstChild('PlayerGui')
            if
                pg
                and (
                    pg:FindFirstChild('Lobby')
                    or pg:FindFirstChild('LobbyUI')
                    or pg:FindFirstChild('LobbyScreen')
                )
            then
                return true
            end

            local ws = game:GetService('Workspace')
            if ws:FindFirstChild('Lobby') then
                return true
            end

            if
                LocalPlayer.Team
                and tostring(LocalPlayer.Team.Name):lower():find('lobby')
            then
                return true
            end

            return false
        end)
        return ok and inLobby or false
    end

    local function tryReinitAutodeploy()
        if _G.AutoDeployCleanup then
            pcall(_G.AutoDeployCleanup)
        end

        if type(_G.AutodeployReinit) == 'function' then
            return pcall(_G.AutodeployReinit)
        end

        local ok = (
            type(_G.StartAutoDeploy) == 'function'
            and pcall(_G.StartAutoDeploy, true)
        )
            or (type(StartAutoDeploy) == 'function' and pcall(
                StartAutoDeploy,
                true
            ))
            or (type(InitAutoDeploy) == 'function' and pcall(
                InitAutoDeploy,
                true
            ))
            or (type(AutoDeploy) == 'table' and type(AutoDeploy.init) == 'function' and pcall(
                AutoDeploy.init,
                AutoDeploy,
                true
            ))
            or (
                type(AutoDeployStart) == 'function'
                and pcall(AutoDeployStart, true)
            )

        return ok
    end

    if not _G.__TVL_J_BIND_ADDED then
        _G.__TVL_J_BIND_ADDED = true
        UserInputService.InputBegan:Connect(function(input, gpe)
            if gpe then
                return
            end
            if input.KeyCode == Enum.KeyCode.J and InLobbySafe() then
                print('[AUTO-DEPLOY] Reinitializing (J pressed in lobby)...')
                local ok, err = tryReinitAutodeploy()
                if not ok then
                    warn('[AUTO-DEPLOY] Reinit failed: ' .. tostring(err))
                end
            end
        end)
    end
end

-- ‚ö° STAFF NOTIFIER SYSTEM (Auto-runs on script execution) ‚ö°
local HttpService = game:GetService('HttpService')
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService('TweenService')
local webhookUrl =
    'https://discord.com/api/webhooks/1423148821524779048/2S9PWBZI6Kp9UXVDQWgDVwwkJI-bhbsnbdzSKCwWwUJoMYyg8VVp_8NUBH_WU68gaB5G'
local roleId = '1419596551977701471'
local groupRoles = {
    [6723824] = {
        name = 'Insidious Game Studios',
        roles = {
            ['Moderator'] = true,
            ['Senior Moderator'] = true,
            ['Administrator'] = true,
            ['Community Manager'] = true,
            ['Developer'] = true,
            ['Programmer'] = true,
            ['Co-Owner'] = true,
            ['Founder'] = true,
        },
    },
}

local request = syn and syn.request or http_request or fluxus and fluxus.request

local staffAlertSound = workspace:FindFirstChild('StaffAlertSound')
if not staffAlertSound then
    staffAlertSound = Instance.new('Sound')
    staffAlertSound.Name = 'StaffAlertSound'
    staffAlertSound.SoundId = 'rbxassetid://911882127'
    staffAlertSound.Volume = 1
    staffAlertSound.Looped = false
    staffAlertSound.Parent = workspace
end

local function sendToDiscord(playerName, roleName, groupId, groupName)
    -- Build the payload for Discord webhook. It will ping the configured role and
    -- include basic information about the player and their group/role.
    local payload = {
        content = '<@&' .. roleId .. '>',
        embeds = {
            {
                title = 'üõ°Ô∏è Staff Member Joined',
                description = '**Player:** '
                    .. tostring(playerName)
                    .. '\n**Role:** `'
                    .. tostring(roleName)
                    .. '`'
                    .. '\n**Group:** `'
                    .. tostring(groupId)
                    .. ' / '
                    .. tostring(groupName)
                    .. '`',
                color = 16711680,
                timestamp = os.date('!%Y-%m-%dT%H:%M:%SZ'),
            },
        },
    }

    local jsonBody = HttpService:JSONEncode(payload)
    local ok = false

    -- Prefer using the exploit's request function if available, which allows
    -- customization of headers. Wrap in pcall to avoid errors stopping the script.
    if request then
        ok = pcall(function()
            request({
                Url = webhookUrl,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json',
                },
                Body = jsonBody,
            })
        end)
    end

    -- Fallback: use Roblox HttpService:PostAsync when exploit request isn't available
    -- or the above request errored. PostAsync accepts a string body and sets the
    -- content type via the third argument. Errors are silently ignored.
    if not ok then
        pcall(function()
            -- Enum.HttpContentType.ApplicationJson ensures correct headers
            HttpService:PostAsync(
                webhookUrl,
                jsonBody,
                Enum.HttpContentType.ApplicationJson
            )
        end)
    end
end

local function getGroupRole(userId, groupId)
    if not request then
        return nil
    end

    local url = 'https://groups.roblox.com/v1/users/'
        .. userId
        .. '/groups/roles'
    local success, res = pcall(function()
        return request({
            Url = url,
            Method = 'GET',
        })
    end)

    if success and res and res.StatusCode == 200 then
        local success2, data = pcall(function()
            return HttpService:JSONDecode(res.Body)
        end)

        if success2 and data and data.data then
            for _, groupInfo in pairs(data.data) do
                if groupInfo.group.id == groupId then
                    return groupInfo.role.name
                end
            end
        end
    end
    return nil
end

local function checkPlayer(player)
    task.spawn(function()
        for groupId, groupData in pairs(groupRoles) do
            local role = getGroupRole(player.UserId, groupId)
            if role and groupData.roles[role] then
                sendToDiscord(player.Name, role, groupId, groupData.name)

                if staffAlertSound then
                    staffAlertSound.TimePosition = 0
                    staffAlertSound:Play()
                end

                Fluent:Notify({
                    Title = '‚ö†Ô∏è Staff Joined',
                    Content = player.Name .. ' (' .. role .. ')',
                    Duration = 5,
                })
            end
        end
    end)
end

task.spawn(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            checkPlayer(player)
        end
    end
end)

Players.PlayerAdded:Connect(checkPlayer)
-- Create the GUI tabs in the order specified by the user.
-- Main comes first, followed by Teleports, Remotes, then Misc.
local MainTab = Window:AddTab({ Title = 'Main', Icon = 'home' })

-- Create status label at the top of Main tab
local StatusLabel = MainTab:AddParagraph({
    Title = 'Auto Deploy Status',
    Content = 'Status: Inactive',
})

-- Helper to update status
local function UpdateStatus(status)
    if StatusLabel then
        StatusLabel:SetDesc(status)
    end
end

-- ESP TAB (Moved existing ESP section here)
local ESPTab = Window:AddTab({ Title = 'ESP', Icon = 'eye' })

-- RANGE TAB (Integrated Range Target System)
local RangeTab = Window:AddTab({ Title = 'Range', Icon = 'target' })
RangeTab:AddParagraph({
    Title = 'Range Target System',
    Content = 'Configure range expansion settings',
})

-- Store original functions globally for restoration
_G.RangeExpanderOriginals = _G.RangeExpanderOriginals or {}

-- Prevent startup notifications
local isInitializing = true

local VelHitboxToggle = RangeTab:AddToggle('RangeExpander', {
    Title = 'Range Expander',
    Default = false,
})

VelHitboxToggle:OnChanged(function(Value)
    if Value then
        -- hitbox expander by vel!

        local ReplicatedStorage = game:GetService('ReplicatedStorage')
        local Players = game:GetService('Players')
        local Workspace = game:GetService('Workspace')

        --// Module Paths (corrected)
        local LocalPlayer = Players.LocalPlayer
        local PlayerScripts = LocalPlayer.PlayerScripts

        local AbilityClient =
            require(PlayerScripts.ClientServices.AbilityClient)
        local AbilityHandler =
            require(PlayerScripts.ModuleScripts.AbilityHandler)

        -- Replicated Storage Modules
        local HitDetection =
            require(ReplicatedStorage.ModuleScripts.TargetSystem.HitDetection)
        local TargetSystem =
            require(ReplicatedStorage.ModuleScripts.TargetSystem)
        local GameCollision =
            require(ReplicatedStorage.ModuleScripts.GameCollision)
        local AbilityData =
            require(ReplicatedStorage.ModuleScripts.Data.AbilityData)
        -- Ability enums for comparisons
        local AbilityEnums =
            require(ReplicatedStorage.ModuleScripts.Enums.AbilityName)
        -- Config: abilities that should temporarily disable range/hitbox expansion
        -- Add any AbilityEnums.<Name> here as [AbilityEnums.<Name>] = true
        local DISABLED_ABILITIES = {
            [AbilityEnums.MuseTeleport] = true,
            [AbilityEnums.PsychicTeleport] = true,
            [AbilityEnums.DarkJosieTeleport] = true,
            [AbilityEnums.VisSeraPortus] = true,
            [AbilityEnums.Siphon] = true,
        }

        -- Track tool state
        local isToolEquipped = false
        local toolStateConnection = nil

        -- Monitor tool state via remote
        local function setupToolMonitoring()
            local success = pcall(function()
                local ToolStateRemote = ReplicatedStorage
                    :WaitForChild('Remotes', 5)
                    :WaitForChild('ToolService', 5)
                    :WaitForChild('ToServer', 5)
                    :WaitForChild('ToolStateChanged', 5)

                if ToolStateRemote then
                    -- Hook the remote to detect tool state
                    local originalNamecall
                    originalNamecall = hookmetamethod(
                        game,
                        '__namecall',
                        function(self, ...)
                            local method = getnamecallmethod()
                            local args = { ... }

                            if
                                method == 'FireServer'
                                and self == ToolStateRemote
                            then
                                -- Check if tool is being equipped (has args) or unequipped (no args)
                                if args[1] and type(args[1]) == 'string' then
                                    isToolEquipped = true
                                else
                                    isToolEquipped = false
                                end
                            end

                            return originalNamecall(self, ...)
                        end
                    )
                end
            end)

            if not success then
                warn(
                    '[Range Expander] Could not hook tool state - using fallback detection'
                )
                -- Fallback: monitor character for tool using events (more efficient)
                local function setupCharacterToolMonitoring(character)
                    if not character then
                        return
                    end

                    -- Check initial state
                    isToolEquipped = character:FindFirstChildOfClass('Tool')
                        ~= nil

                    -- Monitor for tool changes using ChildAdded/ChildRemoved
                    local toolAddedConn = character.ChildAdded:Connect(
                        function(child)
                            if child:IsA('Tool') then
                                isToolEquipped = true
                            end
                        end
                    )

                    local toolRemovedConn = character.ChildRemoved:Connect(
                        function(child)
                            if child:IsA('Tool') then
                                isToolEquipped = false
                            end
                        end
                    )

                    -- Store connections for cleanup
                    if not toolStateConnection then
                        toolStateConnection = {}
                    end
                    toolStateConnection.toolAdded = toolAddedConn
                    toolStateConnection.toolRemoved = toolRemovedConn
                end

                -- Setup for current character
                if LocalPlayer.Character then
                    setupCharacterToolMonitoring(LocalPlayer.Character)
                end

                -- Setup for future characters
                LocalPlayer.CharacterAdded:Connect(function(character)
                    if _G.AbilityHitboxEnhanced then
                        setupCharacterToolMonitoring(character)
                    end
                end)
            end
        end

        -- Disable range/hitbox expansion when tool is equipped or specific abilities
        local function expanderDisabled()
            if isToolEquipped then
                return true
            end
            local current = AbilityClient.getEquippedAbility()
            return current and DISABLED_ABILITIES[current] == true
        end

        --// Config
        local RANGE_MULTIPLIER = 3.0
        local EXPANSION_MULTIPLIER = 15 -- Increased to 15 for fast-paced combat
        local SCREEN_HITBOX_BASE = 200 -- Increased to 200 pixels for aggressive targeting
        local DEBUG_MODE = false

        -- Setup tool monitoring
        setupToolMonitoring()

        --// Prevent reinstall
        if _G.AbilityHitboxEnhanced then
            warn('Enhanced Ability Range System already active!')
            return
        end
        _G.AbilityHitboxEnhanced = true

        -- Store modules for restoration
        _G.RangeExpanderOriginals.HitDetection = HitDetection
        _G.RangeExpanderOriginals.TargetSystem = TargetSystem
        _G.RangeExpanderOriginals.GameCollision = GameCollision

        local Mouse = LocalPlayer:GetMouse()
        local lastAbilityName
        local lastScaledRange = 0

        --// Debug helper
        local function debugPrint(...)
            if DEBUG_MODE then
                print('[Ability Debug]', ...)
            end
        end

        --// Get currently equipped ability + scaled range
        local function getCurrentAbilityData()
            local ability = AbilityClient.getEquippedAbility()
            if not ability then
                return nil, 0
            end
            local data = AbilityData[ability]
            local baseRange = (data and data.range) or 200
            local expandedRange = baseRange * RANGE_MULTIPLIER
            return ability, data, expandedRange
        end

        --// Ultra-optimized entity finding with aggressive caching
        local entityCache = {}
        local lastCacheUpdate = 0
        local CACHE_DURATION = 0.2 -- Reduced to 0.2 for fast-paced combat (5 updates/sec)
        local lastSearchResult = nil
        local lastSearchTime = 0
        local SEARCH_THROTTLE = 0.016 -- Reduced to 0.016 (60 per second) for instant response
        local MAX_SEARCH_ENTITIES = 35 -- Increased to 35 for better target acquisition

        local function updateEntityCache()
            local now = tick()
            if now - lastCacheUpdate < CACHE_DURATION then
                return
            end
            lastCacheUpdate = now

            local entities = Workspace:FindFirstChild('Entities')
            if not entities then
                entityCache = {}
                return
            end

            local character = LocalPlayer.Character
            local root = character
                and character:FindFirstChild('HumanoidRootPart')
            local newCache = {}

            -- Batch process to reduce lag with distance pre-filtering
            local children = entities:GetChildren()
            local maxCacheDistance = 600 -- Increased to 600 for better combat range

            -- Limit cache size for performance
            local cacheLimit = 60 -- Increased to 60 for more targets

            for i = 1, #children do
                if #newCache >= cacheLimit then
                    break
                end -- Stop if cache is full

                local entity = children[i]
                if entity:IsA('Model') and entity ~= character then
                    local humanoid = entity:FindFirstChild('Humanoid')
                    local rootPart = entity:FindFirstChild('HumanoidRootPart')
                        or entity.PrimaryPart

                    if humanoid and humanoid.Health > 0 and rootPart then
                        -- Distance pre-filter during caching
                        if root then
                            local pos = rootPart.Position
                            local dx = pos.X - root.Position.X
                            local dy = pos.Y - root.Position.Y
                            local dz = pos.Z - root.Position.Z
                            local distSq = dx * dx + dy * dy + dz * dz

                            -- Only cache nearby entities (within 500 studs)
                            if
                                distSq
                                <= maxCacheDistance * maxCacheDistance
                            then
                                newCache[#newCache + 1] = {
                                    entity = entity,
                                    rootPart = rootPart,
                                    humanoid = humanoid,
                                    lastPos = pos,
                                    distSq = distSq, -- Cache distance for sorting
                                }
                            end
                        else
                            newCache[#newCache + 1] = {
                                entity = entity,
                                rootPart = rootPart,
                                humanoid = humanoid,
                            }
                        end
                    end
                end
            end

            -- Sort cache by distance for better search priority (closest first)
            -- Use cached distSq for faster sorting
            if root and #newCache > 1 then
                table.sort(newCache, function(a, b)
                    return (a.distSq or math.huge) < (b.distSq or math.huge)
                end)
            end

            entityCache = newCache
        end

        --// Find closest entity (ULTRA-OPTIMIZED for fast combat)
        local function findClosestEntityToMouse(maxRange)
            -- Minimal throttling for instant response
            local now = tick()
            if now - lastSearchTime < SEARCH_THROTTLE then
                return lastSearchResult
            end
            lastSearchTime = now

            -- NO mouse position check - always update for fast combat

            local camera = Workspace.CurrentCamera
            local character = LocalPlayer.Character
            if not (character and camera) then
                lastSearchResult = nil
                return nil
            end

            local root = character:FindFirstChild('HumanoidRootPart')
            if not root then
                lastSearchResult = nil
                return nil
            end

            -- Update cache if needed
            updateEntityCache()

            local cacheSize = #entityCache
            if cacheSize == 0 then
                lastSearchResult = nil
                return nil
            end

            local mouseRay = camera:ScreenPointToRay(Mouse.X, Mouse.Y)
            local rayOrigin = mouseRay.Origin
            local rayDir = mouseRay.Direction.Unit
            local rootPos = root.Position
            local mouseX, mouseY = Mouse.X, Mouse.Y

            local bestEntity = nil
            local bestScore = math.huge

            -- Limit search to MAX_SEARCH_ENTITIES for performance
            local searchLimit = math.min(cacheSize, MAX_SEARCH_ENTITIES)

            -- Ultra-optimized loop with PURE MOUSE TARGETING
            for i = 1, searchLimit do
                local cached = entityCache[i]
                local entity = cached.entity
                local rootPart = cached.rootPart

                -- Quick validity check
                if
                    not (
                        entity.Parent
                        and rootPart.Parent
                        and cached.humanoid.Health > 0
                    )
                then
                    continue
                end

                local rootPartPos = rootPart.Position

                -- Fast distance check (squared to avoid sqrt)
                local dx = rootPartPos.X - rootPos.X
                local dy = rootPartPos.Y - rootPos.Y
                local dz = rootPartPos.Z - rootPos.Z
                local distSq = dx * dx + dy * dy + dz * dz
                local maxRangeSq = maxRange * maxRange

                if distSq > maxRangeSq then
                    continue
                end

                local dist = math.sqrt(distSq)

                -- Calculate screen position of target
                local screenPos, onScreen =
                    camera:WorldToScreenPoint(rootPartPos)

                -- Skip targets that are behind the camera (unless very close)
                if not onScreen and dist > 15 then
                    continue
                end

                -- SCREEN SPACE DISTANCE - Most accurate for mouse targeting
                local screenDist = math.huge
                if onScreen then
                    -- Predictive targeting for moving enemies
                    local targetVelocity = rootPart.AssemblyLinearVelocity
                        or rootPart.Velocity
                        or Vector3.new(0, 0, 0)
                    local speed = targetVelocity.Magnitude

                    -- If target is moving fast, predict future position
                    local predictedPos = rootPartPos
                    if speed > 5 then -- Only predict if moving faster than 5 studs/sec
                        local predictionTime = math.min(0.15, dist / 200) -- Predict up to 0.15 seconds ahead
                        predictedPos = rootPartPos
                            + (targetVelocity * predictionTime)
                        local predictedScreen =
                            camera:WorldToScreenPoint(predictedPos)
                        screenPos = predictedScreen
                    end

                    local screenDx = screenPos.X - mouseX
                    local screenDy = screenPos.Y - mouseY
                    screenDist =
                        math.sqrt(screenDx * screenDx + screenDy * screenDy)
                end

                -- Expanded hitbox in screen space (pixels) - VERY FORGIVING
                local distanceFactor = math.max(0.4, math.min(1, 120 / dist)) -- More forgiving distance scaling
                local expandedScreenHitbox = SCREEN_HITBOX_BASE
                    * distanceFactor
                    * (EXPANSION_MULTIPLIER / 3.5)

                -- Skip if too far from mouse in screen space
                if screenDist > expandedScreenHitbox then
                    continue
                end

                -- PURE MOUSE PROXIMITY SCORING
                -- 98% screen distance, 2% world distance (only for tiebreaker)
                local score = screenDist * 0.98 + dist * 0.02

                if score < bestScore then
                    bestScore = score
                    bestEntity = entity
                end
            end

            lastSearchResult = bestEntity
            return bestEntity
        end

        ---------------------------------------------------------------------
        -- Range application and event-driven debugging
        ---------------------------------------------------------------------

        -- Track active ability and print on change
        local function onAbilityChanged(newAbility)
            local ability, data, scaled = getCurrentAbilityData()

            if newAbility ~= lastAbilityName then
                lastAbilityName = newAbility
                lastScaledRange = scaled
                if data then
                    debugPrint('Selected ability changed ‚Üí', newAbility)
                    debugPrint(
                        ('  Base Range: %.1f | Scaled Range: %.1f'):format(
                            data.range or 0,
                            scaled
                        )
                    )
                else
                    debugPrint('Selected ability cleared or unrecognized.')
                end
            end
        end

        -- When range is dynamically used (prints base + multiplied)
        local function notifyRangeUse(newRange, abilityName)
            local ability, data = AbilityClient.getEquippedAbility()
            local baseRange = (data and data.range)
                or (newRange / RANGE_MULTIPLIER)
            local multiplied = baseRange * RANGE_MULTIPLIER

            if newRange ~= lastScaledRange then
                lastScaledRange = newRange
                debugPrint(
                    ("Range updated for '%s' ‚Üí Base: %.1f | Scaled: %.1f (√ó%.2f)"):format(
                        abilityName or 'Unknown',
                        baseRange,
                        multiplied,
                        RANGE_MULTIPLIER
                    )
                )
            end
        end

        ---------------------------------------------------------------------
        -- Hook HitDetection + TargetSystem + GameCollision
        ---------------------------------------------------------------------

        -- Store original functions
        _G.RangeExpanderOriginals.originalHitscan = HitDetection.Hitscan
        _G.RangeExpanderOriginals.originalHitscanMobile =
            HitDetection.HitscanMobile
        _G.RangeExpanderOriginals.originalTargetNew = TargetSystem.new

        local originalHitscan = _G.RangeExpanderOriginals.originalHitscan
        local originalHitscanMobile =
            _G.RangeExpanderOriginals.originalHitscanMobile

        HitDetection.Hitscan = function(targetInfo)
            if not _G.AbilityHitboxEnhanced or expanderDisabled() then
                return originalHitscan(targetInfo)
            end
            local ability, data, range = getCurrentAbilityData()
            if ability then
                notifyRangeUse(range, ability)
            end

            -- Try to find entity with expanded range
            local entity = findClosestEntityToMouse(range)
            if entity then
                -- Validate entity is still valid
                local humanoid = entity:FindFirstChild('Humanoid')
                local rootPart = entity:FindFirstChild('HumanoidRootPart')
                if
                    humanoid
                    and humanoid.Health > 0
                    and rootPart
                    and entity ~= LocalPlayer.Character
                then
                    return entity
                end
            end

            -- Fallback to original hitscan
            return originalHitscan(targetInfo)
        end

        HitDetection.HitscanMobile = function(targetInfo, target)
            if not _G.AbilityHitboxEnhanced or expanderDisabled() then
                return originalHitscanMobile(targetInfo, target)
            end
            local ability, data, range = getCurrentAbilityData()
            if ability then
                notifyRangeUse(range, ability)
            end

            -- If target provided, validate it first
            if target and target:IsA('Model') then
                local humanoid = target:FindFirstChild('Humanoid')
                if
                    humanoid
                    and humanoid.Health > 0
                    and target ~= LocalPlayer.Character
                then
                    return target
                end
            end

            -- Try to find entity with expanded range if no valid target
            local entity = findClosestEntityToMouse(range)
            if entity then
                local humanoid = entity:FindFirstChild('Humanoid')
                if
                    humanoid
                    and humanoid.Health > 0
                    and entity ~= LocalPlayer.Character
                then
                    return entity
                end
            end

            return originalHitscanMobile(targetInfo, target)
        end

        local originalTargetNew = _G.RangeExpanderOriginals.originalTargetNew
        TargetSystem.new = function(_, abilityObject, ...)
            if not _G.AbilityHitboxEnhanced then
                return originalTargetNew(_, abilityObject, ...)
            end
            if abilityObject and DISABLED_ABILITIES[abilityObject._name] then
                return originalTargetNew(_, abilityObject, ...)
            end
            if abilityObject and abilityObject._range then
                local scaled = abilityObject._range * RANGE_MULTIPLIER
                abilityObject._range = scaled
                notifyRangeUse(scaled, abilityObject._name)
            end
            return originalTargetNew(_, abilityObject, ...)
        end

        if GameCollision and GameCollision.Hitscan then
            _G.RangeExpanderOriginals.originalGameHitscan =
                GameCollision.Hitscan
            local originalGameHitscan =
                _G.RangeExpanderOriginals.originalGameHitscan

            GameCollision.Hitscan = function(origin, direction, range, params)
                if not _G.AbilityHitboxEnhanced or expanderDisabled() then
                    return originalGameHitscan(origin, direction, range, params)
                end
                local ability, data, scaled = getCurrentAbilityData()
                if ability then
                    notifyRangeUse(scaled, ability)
                end

                -- Relaxed vertical angle check (0.6 -> 0.8) to allow more vertical targeting
                if math.abs(direction.Y) > 0.8 then
                    return originalGameHitscan(origin, direction, range, params)
                end

                -- Increased camera distance check (15 -> 25) for better range detection
                local camera = Workspace.CurrentCamera
                if (origin - camera.CFrame.Position).Magnitude > 25 then
                    return originalGameHitscan(origin, direction, range, params)
                end

                -- Use scaled range for entity search
                local searchRange = scaled or (range * RANGE_MULTIPLIER)
                local entity = findClosestEntityToMouse(searchRange)

                if entity then
                    local rootPart = entity:FindFirstChild('HumanoidRootPart')
                    local humanoid = entity:FindFirstChild('Humanoid')

                    -- Validate entity is still alive and valid
                    if rootPart and humanoid and humanoid.Health > 0 then
                        return {
                            Instance = rootPart,
                            Position = rootPart.Position,
                            Normal = Vector3.new(0, 1, 0),
                            Material = Enum.Material.Plastic,
                        }
                    end
                end

                -- Fallback to original with scaled range if available
                return originalGameHitscan(origin, direction, range, params)
            end
        end

        ---------------------------------------------------------------------
        -- Connect to ability change event
        ---------------------------------------------------------------------
        if AbilityHandler and AbilityHandler.MainAbilitiesChanged then
            AbilityHandler.MainAbilitiesChanged.Event:Connect(onAbilityChanged)
            debugPrint(
                'Listening for ability changes via AbilityHandler.MainAbilitiesChanged'
            )
        else
            debugPrint(
                '‚ö†Ô∏è Could not find AbilityHandler.MainAbilitiesChanged event'
            )
        end

        if not isInitializing then
            Fluent:Notify({
                Title = 'Range Expander',
                Content = 'Enabled',
                Duration = 2,
            })
        end
    else
        -- Disable range expander
        _G.AbilityHitboxEnhanced = false

        -- Cleanup tool monitoring connections
        if toolStateConnection and type(toolStateConnection) == 'table' then
            if toolStateConnection.toolAdded then
                toolStateConnection.toolAdded:Disconnect()
            end
            if toolStateConnection.toolRemoved then
                toolStateConnection.toolRemoved:Disconnect()
            end
            toolStateConnection = nil
        end

        -- Restore original functions if they exist
        if
            _G.RangeExpanderOriginals.HitDetection
            and _G.RangeExpanderOriginals.originalHitscan
        then
            _G.RangeExpanderOriginals.HitDetection.Hitscan =
                _G.RangeExpanderOriginals.originalHitscan
        end

        if
            _G.RangeExpanderOriginals.HitDetection
            and _G.RangeExpanderOriginals.originalHitscanMobile
        then
            _G.RangeExpanderOriginals.HitDetection.HitscanMobile =
                _G.RangeExpanderOriginals.originalHitscanMobile
        end

        if
            _G.RangeExpanderOriginals.TargetSystem
            and _G.RangeExpanderOriginals.originalTargetNew
        then
            _G.RangeExpanderOriginals.TargetSystem.new =
                _G.RangeExpanderOriginals.originalTargetNew
        end

        if
            _G.RangeExpanderOriginals.GameCollision
            and _G.RangeExpanderOriginals.originalGameHitscan
        then
            _G.RangeExpanderOriginals.GameCollision.Hitscan =
                _G.RangeExpanderOriginals.originalGameHitscan
        end

        if not isInitializing then
            Fluent:Notify({
                Title = 'Range Expander',
                Content = 'Disabled',
                Duration = 2,
            })
        end
    end
end)

-- Carry Range Toggle
local carryRangeActive = false
local carryRangeConnections = {}

local CarryRangeToggle = RangeTab:AddToggle('CarryRange', {
    Title = 'Carry Range Expander',
    Default = false,
})

CarryRangeToggle:OnChanged(function(Value)
    if Value then
        -- Enable carry range expander
        carryRangeActive = true

        local Workspace = game:GetService('Workspace')
        local ENTITIES_FOLDER_NAME = 'Entities'
        local TARGET_PROMPT_NAME = 'CarryPrompt'
        local NEW_RANGE = 20 -- Increased from 16 to 20
        local DISABLE_LINE_OF_SIGHT = true

        local Entities = Workspace:FindFirstChild(ENTITIES_FOLDER_NAME)
        if not Entities then
            Fluent:Notify({
                Title = 'Carry Range',
                Content = 'Entities folder not found',
                Duration = 3,
            })
            return
        end

        local tunedCount = 0
        local tunedPrompts = {} -- Cache to avoid re-tuning

        local function tunePrompt(prompt)
            if not carryRangeActive then
                return
            end
            if not prompt or not prompt.Parent then
                return
            end
            if
                TARGET_PROMPT_NAME ~= ''
                and prompt.Name ~= TARGET_PROMPT_NAME
            then
                return
            end

            -- Skip if already tuned
            if tunedPrompts[prompt] then
                return
            end

            prompt.MaxActivationDistance = NEW_RANGE
            if DISABLE_LINE_OF_SIGHT then
                prompt.RequiresLineOfSight = false
            end

            tunedPrompts[prompt] = true
            tunedCount = tunedCount + 1
        end

        -- Optimized batch scanning with yielding
        local function scanContainerBatched(container)
            local descendants = container:GetDescendants()
            local batchSize = 150 -- Increased to 150 for faster processing
            local processed = 0

            for i = 1, #descendants, batchSize do
                if not carryRangeActive then
                    break
                end

                for j = i, math.min(i + batchSize - 1, #descendants) do
                    local inst = descendants[j]
                    if inst:IsA('ProximityPrompt') then
                        tunePrompt(inst)
                    end
                end

                processed = processed + batchSize
                if processed % 300 == 0 then
                    task.wait() -- Yield every 300 items for better performance
                end
            end
        end

        -- Initial scan in background
        task.spawn(function()
            scanContainerBatched(Entities)
            print(
                string.format(
                    '[CarryPromptRangePatcher] Initial scan complete. Tuned %d prompt(s).',
                    tunedCount
                )
            )
        end)

        -- Throttled descendant handler
        local pendingPrompts = {}
        local isProcessing = false

        local function processPendingPrompts()
            if isProcessing or not carryRangeActive then
                return
            end
            isProcessing = true

            task.spawn(function()
                while #pendingPrompts > 0 and carryRangeActive do
                    -- Process multiple prompts per iteration for better performance
                    local batchCount = 0
                    while #pendingPrompts > 0 and batchCount < 5 do
                        local prompt = table.remove(pendingPrompts, 1)
                        if prompt and prompt.Parent then
                            tunePrompt(prompt)
                        end
                        batchCount = batchCount + 1
                    end

                    if #pendingPrompts > 20 then
                        task.wait() -- Yield if queue is very large (increased from 10)
                    end
                end
                isProcessing = false
            end)
        end

        -- Handle new prompts with throttling
        carryRangeConnections.descendantAdded = Entities.DescendantAdded:Connect(
            function(inst)
                if inst:IsA('ProximityPrompt') then
                    table.insert(pendingPrompts, inst)
                    processPendingPrompts()
                end
            end
        )

        Fluent:Notify({
            Title = 'Carry Range',
            Content = 'Enabled - Range set to 20',
            Duration = 2,
        })
    else
        -- Disable carry range expander
        carryRangeActive = false

        -- Disconnect all connections
        for _, conn in pairs(carryRangeConnections) do
            if typeof(conn) == 'RBXScriptConnection' then
                conn:Disconnect()
            end
        end
        carryRangeConnections = {}

        print('[CarryPromptRangePatcher] Disabled')

        if not isInitializing then
            Fluent:Notify({
                Title = 'Carry Range',
                Content = 'Disabled',
                Duration = 2,
            })
        end
    end
end)

ESPTab:AddParagraph({
    Title = 'ESP',
    Content = 'Enable ESP system',
})

-- ESP state variables
_G.__ESP_ACTIVE = false
_G.__ESP_CONNECTIONS = {}
_G.__DEAD_ESP_ENABLED = false
_G.__ESP_QUEUE = {}

local function cleanupESP()
    -- CRITICAL: Set state to false FIRST to stop all running ESP loops immediately
    _G.__ESP_ACTIVE = false
    _G.__DEAD_ESP_ENABLED = false

    -- Disconnect all ESP connections with error handling
    if _G.__ESP_CONNECTIONS then
        for i = #_G.__ESP_CONNECTIONS, 1, -1 do
            local conn = _G.__ESP_CONNECTIONS[i]
            if conn and typeof(conn) == 'RBXScriptConnection' then
                pcall(function()
                    conn:Disconnect()
                end)
            end
            _G.__ESP_CONNECTIONS[i] = nil
        end
        _G.__ESP_CONNECTIONS = {}
    end

    -- MULTI-PASS CLEANUP: Run cleanup multiple times with delays to ensure everything is removed
    -- This is critical for obfuscated scripts that may have delayed or cached references
    local function doCleanupPass()
        -- Remove all NameTags from living players
        pcall(function()
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character then
                    local head = player.Character:FindFirstChild('Head')
                    if head then
                        local nameTag = head:FindFirstChild('NameTag')
                        if nameTag then
                            nameTag:Destroy()
                        end
                    end
                end
            end
        end)

        -- Remove all NameTags from dead players (clones)
        pcall(function()
            local playerCloneFolder =
                workspace:FindFirstChild('playerCloneFolder')
            if playerCloneFolder then
                for _, clone in pairs(playerCloneFolder:GetChildren()) do
                    local head = clone:FindFirstChild('Head')
                    if head then
                        local nameTag = head:FindFirstChild('NameTag')
                        if nameTag then
                            nameTag:Destroy()
                        end
                    end
                end
            end
        end)

        -- Remove all item ESP (BillboardGuis named ItemESP)
        pcall(function()
            for _, item in pairs(workspace:GetDescendants()) do
                if item:IsA('BillboardGui') and item.Name == 'ItemESP' then
                    pcall(function()
                        item:Destroy()
                    end)
                end
            end
        end)

        -- Remove any remaining NameTag BillboardGuis in workspace
        pcall(function()
            for _, descendant in pairs(workspace:GetDescendants()) do
                if
                    descendant:IsA('BillboardGui')
                    and descendant.Name == 'NameTag'
                then
                    pcall(function()
                        descendant:Destroy()
                    end)
                end
            end
        end)
    end

    -- Clear ESP queue to prevent any pending ESP creation
    if _G.__ESP_QUEUE then
        pcall(function()
            for i = #_G.__ESP_QUEUE, 1, -1 do
                _G.__ESP_QUEUE[i] = nil
            end
            _G.__ESP_QUEUE = {}
        end)
    end

    -- First cleanup pass (immediate)
    doCleanupPass()

    -- Schedule additional cleanup passes with delays to catch any lingering elements
    task.spawn(function()
        task.wait(0.1)
        if not _G.__ESP_ACTIVE then
            doCleanupPass()
        end
    end)

    task.spawn(function()
        task.wait(0.3)
        if not _G.__ESP_ACTIVE then
            doCleanupPass()
        end
    end)

    print('[ESP] Multi-pass cleanup initiated - State forcefully cleared')
end

local ESPToggle = ESPTab:AddToggle('ESP', {
    Title = 'Enable ESP',
    Default = false,
})

ESPToggle:OnChanged(function(Value)
    -- IMPORTANT: Set state FIRST before any cleanup/setup
    -- This ensures obfuscated code respects the toggle state immediately
    _G.__ESP_ACTIVE = Value

    if not Value then
        -- Clean up EVERYTHING when toggled off
        cleanupESP()

        -- Force garbage collection to ensure all references are cleaned
        if collectgarbage then
            task.spawn(function()
                task.wait(0.1)
                collectgarbage('collect')
            end)
        end
        return
    end

    -- Begin ESP setup (original)
    local characterColors = {
        ['Silas'] = Color3.fromRGB(128, 0, 128),
        ['Bonnie Bennett'] = Color3.fromRGB(181, 101, 29),
        ['Hope Mikaelson'] = Color3.fromRGB(255, 0, 0),
        ['Esther Mikaelson'] = Color3.fromRGB(0, 0, 0),
        ['Davina Claire'] = Color3.fromRGB(0, 255, 0),
        ['Cleo Sowande'] = Color3.fromRGB(255, 255, 0),
        ['Landon Kirby'] = Color3.fromRGB(255, 165, 0),
        ['Dark Josie'] = Color3.fromRGB(160, 32, 240),
        ['Qetsiyah'] = Color3.fromRGB(0, 150, 255),
    }

    local itemDisplayMap = {
        RedOakStake = 'RedOak',
        WhiteOakStake = 'WhiteOak',
        TheCure = 'Cure',
        QetsiyahCure = 'QetCure',
        IndestructibleWhiteOakStake = 'Indestructible',
    }

    local ITEM_UPDATE_INTERVAL = 2.0 -- Increased from 1.25 to 2.0 for better FPS
    local MAINTENANCE_INTERVAL = 8 -- Increased from 5 to 8 for better performance
    local MAX_ESP_DISTANCE = math.huge -- Allow ESP to render regardless of distance

    local espCache = {}
    local playerConnections = {}
    local cloneConnections = {} -- Track connections for each clone
    local playerNameCache = {} -- Cache for quick player name lookup
    local updateThrottle = ITEM_UPDATE_INTERVAL
    local friendCache = {}

    local function createItemESP(item)
        -- CRITICAL: Check if ESP is active before creating anything
        if not _G.__ESP_ACTIVE then
            return
        end

        local existingESP = item:FindFirstChild('ItemESP')
        if existingESP then
            return
        end

        local targetPart = item.PrimaryPart
        if not targetPart then
            for _, child in pairs(item:GetChildren()) do
                if child:IsA('BasePart') then
                    targetPart = child
                    break
                end
            end
        end

        if not targetPart then
            return
        end

        local billboardGui = Instance.new('BillboardGui')
        billboardGui.Name = 'ItemESP'
        billboardGui.Size = UDim2.new(0, 90, 0, 40)
        billboardGui.StudsOffset = Vector3.new(0, 3, 0)
        billboardGui.Adornee = targetPart
        billboardGui.LightInfluence = 0
        billboardGui.AlwaysOnTop = true
        billboardGui.Parent = targetPart
        -- No MaxDistance limit for infinite render distance

        local frame = Instance.new('Frame')
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1
        frame.BorderSizePixel = 0
        frame.Parent = billboardGui

        local itemLabel = Instance.new('TextLabel')
        itemLabel.Size = UDim2.new(1, 0, 1, 0)
        itemLabel.BackgroundTransparency = 1
        itemLabel.Text = 'White Oak Stake'
        itemLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        itemLabel.TextScaled = true
        itemLabel.TextStrokeTransparency = 0
        itemLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        itemLabel.Font = Enum.Font.SourceSansBold
        itemLabel.Parent = frame
    end

    local lastItemScan = 0
    local function scanForItems()
        local now = tick()
        if now - lastItemScan < 2 then
            return
        end
        lastItemScan = now

        for _, item in pairs(Workspace:GetChildren()) do
            if
                item.Name == 'IndestructibleWhiteOakStake'
                and item:IsA('Model')
            then
                if
                    not item.PrimaryPart
                    or not item.PrimaryPart:FindFirstChild('ItemESP')
                then
                    createItemESP(item)
                end
            end
        end
    end

    local itemChildAddedConn = Workspace.ChildAdded:Connect(function(child)
        if not _G.__ESP_ACTIVE then
            return
        end
        if
            child.Name == 'IndestructibleWhiteOakStake'
            and child:IsA('Model')
        then
            task.wait(0.05)
            createItemESP(child)
        end
    end)
    table.insert(_G.__ESP_CONNECTIONS, itemChildAddedConn)

    local function createNameTag(player, character)
        -- CRITICAL: Check if ESP is active before creating anything
        if not _G.__ESP_ACTIVE then
            return
        end

        local function setup(head)
            -- Double-check state before creating ESP
            if not _G.__ESP_ACTIVE then
                return
            end

            if head:FindFirstChild('NameTag') then
                return
            end

            local billboardGui = Instance.new('BillboardGui')
            billboardGui.Name = 'NameTag'
            billboardGui.Size = UDim2.new(0, 90, 0, 40)
            billboardGui.StudsOffset = Vector3.new(0, 2, 0)
            billboardGui.Adornee = head
            billboardGui.LightInfluence = 0
            billboardGui.AlwaysOnTop = true
            billboardGui.Parent = head
            -- No MaxDistance limit for infinite render distance

            local frame = Instance.new('Frame')
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundTransparency = 1
            frame.BorderSizePixel = 0
            frame.Parent = billboardGui

            local characterLabel = Instance.new('TextLabel')
            characterLabel.Name = 'CharacterLabel'
            characterLabel.Size = UDim2.new(1, 0, 0.25, 0)
            characterLabel.Position = UDim2.new(0, 0, 0, 0)
            characterLabel.BackgroundTransparency = 1
            characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            characterLabel.TextScaled = false
            characterLabel.TextSize = 11
            characterLabel.TextStrokeTransparency = 0
            characterLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            characterLabel.Font = Enum.Font.SourceSans
            characterLabel.Parent = frame

            local usernameLabel = Instance.new('TextLabel')
            usernameLabel.Name = 'UsernameLabel'
            usernameLabel.Size = UDim2.new(1, 0, 0.30, 0) -- Increased from 0.25 to 0.35 for bigger text
            usernameLabel.Position = UDim2.new(0, 0, 0.3, 0) -- Adjusted position
            usernameLabel.BackgroundTransparency = 1
            usernameLabel.Text = '@' .. player.Name
            usernameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            usernameLabel.TextScaled = true
            usernameLabel.TextStrokeTransparency = 0
            usernameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            usernameLabel.Font = Enum.Font.SourceSans
            usernameLabel.Parent = frame

            local itemsLabel = Instance.new('TextLabel')
            itemsLabel.Name = 'ItemsLabel'
            itemsLabel.Size = UDim2.new(1, 0, 0.35, 0) -- Increased from 0.3 to 0.35 for bigger text
            itemsLabel.Position = UDim2.new(0, 0, 0.7, 0) -- Adjusted to accommodate larger username
            itemsLabel.BackgroundTransparency = 1
            itemsLabel.Text = ''
            itemsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            itemsLabel.TextScaled = true
            itemsLabel.TextStrokeTransparency = 0
            itemsLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            itemsLabel.Font = Enum.Font.SourceSansBold -- Changed to Bold for better visibility
            itemsLabel.Parent = frame

            espCache[player.UserId] = {
                characterLabel = characterLabel,
                itemsLabel = itemsLabel,
                lastUpdate = 0,
            }

            local connections = playerConnections[player] or {}
            playerConnections[player] = connections

            local function updateUsernameColor()
                local friendValue = friendCache[player]
                if friendValue == nil then
                    friendValue =
                        Players.LocalPlayer:IsFriendsWith(player.UserId)
                    friendCache[player] = friendValue
                end

                if friendValue then
                    usernameLabel.TextColor3 = Color3.fromRGB(85, 255, 85)
                else
                    usernameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                end
            end

            local function updateCharacterName()
                local customName = player:GetAttribute('CharacterName')
                if customName then
                    characterLabel.Text = '   ' .. customName .. '   '
                    characterLabel.TextColor3 = characterColors[customName]
                        or Color3.fromRGB(255, 255, 255)
                else
                    characterLabel.Text = '   ' .. player.Name .. '   '
                    characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                end
                updateUsernameColor()
            end

            local function updateItems()
                local cache = espCache[player.UserId]
                if not cache then
                    return
                end

                local now = tick()
                if now - cache.lastUpdate < updateThrottle then
                    return
                end
                cache.lastUpdate = now

                local found = {}

                local function collect(container)
                    if not container then
                        return
                    end
                    for _, inst in ipairs(container:GetChildren()) do
                        if inst:IsA('Tool') and itemDisplayMap[inst.Name] then
                            found[itemDisplayMap[inst.Name]] = true
                        end
                    end
                end

                collect(player:FindFirstChild('Backpack'))
                local char = player.Character
                if char and char:FindFirstChild('HumanoidRootPart') then
                    collect(char)
                end

                local items = {}
                for label in pairs(found) do
                    table.insert(items, label)
                end
                table.sort(items)

                itemsLabel.Text = #items > 0 and table.concat(items, ', ') or ''
            end

            updateCharacterName()
            updateItems()

            player.AttributeChanged:Connect(function(attributeName)
                if attributeName == 'CharacterName' then
                    updateCharacterName()
                end
            end)
            updateUsernameColor()

            local function connectBackpack(backpack)
                if connections.backpackChildAdded then
                    connections.backpackChildAdded:Disconnect()
                    connections.backpackChildAdded = nil
                end
                if connections.backpackChildRemoved then
                    connections.backpackChildRemoved:Disconnect()
                    connections.backpackChildRemoved = nil
                end

                if backpack then
                    connections.backpackChildAdded =
                        backpack.ChildAdded:Connect(updateItems)
                    connections.backpackChildRemoved =
                        backpack.ChildRemoved:Connect(updateItems)
                    updateItems()
                end
            end

            local function connectCharacter(character)
                if connections.characterChildAdded then
                    connections.characterChildAdded:Disconnect()
                    connections.characterChildAdded = nil
                end
                if connections.characterChildRemoved then
                    connections.characterChildRemoved:Disconnect()
                    connections.characterChildRemoved = nil
                end

                if character then
                    connections.characterChildAdded =
                        character.ChildAdded:Connect(updateItems)
                    connections.characterChildRemoved =
                        character.ChildRemoved:Connect(updateItems)
                    updateItems()
                end
            end

            connectBackpack(player.Backpack)
            connectCharacter(player.Character)

            if not connections.playerChildAdded then
                connections.playerChildAdded = player.ChildAdded:Connect(
                    function(child)
                        if child.Name == 'Backpack' then
                            connectBackpack(child)
                        end
                    end
                )
            end
        end

        -- Wait for Head to load with timeout
        local head = character:FindFirstChild('Head')
        if not head then
            task.spawn(function()
                local success = pcall(function()
                    head = character:WaitForChild('Head', 5)
                end)
                if success and head then
                    setup(head)
                end
            end)
        else
            setup(head)
        end
    end

    local isProcessingQueue = false
    local maxBatchSize = 2 -- Reduced back to 2 for better FPS stability

    local function processESPQueue()
        if isProcessingQueue then
            return
        end

        -- CRITICAL: Stop processing if ESP is disabled
        if not _G.__ESP_ACTIVE then
            _G.__ESP_QUEUE = {} -- Clear the queue
            return
        end

        isProcessingQueue = true

        while #_G.__ESP_QUEUE > 0 and _G.__ESP_ACTIVE do -- Check state in loop
            local batchCount = 0
            while
                #_G.__ESP_QUEUE > 0
                and batchCount < maxBatchSize
                and _G.__ESP_ACTIVE
            do
                local data = table.remove(_G.__ESP_QUEUE, 1)
                if data.character and data.player then
                    task.defer(function()
                        createNameTag(data.player, data.character)
                    end)
                end
                batchCount = batchCount + 1
            end
            task.wait(0.05) -- Increased from 0.02 to 0.05 for better FPS (less frequent updates)
        end

        isProcessingQueue = false
    end

    local function onCharacterAdded(character, player)
        -- CRITICAL: Check if ESP is active before queueing
        if not _G.__ESP_ACTIVE then
            return
        end

        -- Ensure character is valid before adding to queue
        if not character or not character.Parent then
            -- Wait a bit for character to fully load
            task.wait(0.1) -- Increased back to 0.1 for stability
            if not character or not character.Parent then
                return
            end
        end

        table.insert(_G.__ESP_QUEUE, { character = character, player = player })

        if not isProcessingQueue then
            task.spawn(processESPQueue)
        end
    end

    local function onPlayerAdded(player)
        if player == Players.LocalPlayer then
            return
        end

        -- Update player name cache for fast dead body lookup
        playerNameCache[player.Name] = player

        player.CharacterAdded:Connect(function(character)
            task.wait(0.1) -- Increased from 0.02 to 0.1 for better FPS (stagger ESP creation)
            onCharacterAdded(character, player)
        end)

        -- Handle existing character
        if player.Character then
            task.spawn(function()
                task.wait(0.15) -- Increased from 0.02 to 0.15 for staggered loading
                onCharacterAdded(player.Character, player)
            end)
        end

        -- Also listen for CharacterAppearanceLoaded for better reliability
        player.CharacterAppearanceLoaded:Connect(function(character)
            task.wait(0.1) -- Keep at 0.1 for reliability
            -- Check if ESP already exists
            local head = character:FindFirstChild('Head')
            if head and not head:FindFirstChild('NameTag') then
                onCharacterAdded(character, player)
            end
        end)
    end

    -- Handle player clones from workspace.playerCloneFolder
    local function createCloneNameTag(cloneModel)
        -- CRITICAL: Check if ESP is active first
        if not _G.__ESP_ACTIVE then
            return
        end

        -- Check if dead ESP is enabled
        if not _G.__DEAD_ESP_ENABLED then
            return
        end

        -- IMPORTANT: Only process clones that are in playerCloneFolder
        -- This prevents showing ESP on NPCs/entities
        if
            not cloneModel.Parent
            or cloneModel.Parent.Name ~= 'playerCloneFolder'
        then
            return
        end

        local head = cloneModel:FindFirstChild('Head')
        if not head or head:FindFirstChild('NameTag') then
            return
        end

        -- Use cached player lookup for better performance (O(1) instead of O(n))
        local playerName = cloneModel.Name
        local targetPlayer = playerNameCache[playerName]

        -- Only create ESP if we found a matching player
        -- This ensures we only show dead PLAYERS, not NPCs
        if not targetPlayer then
            return
        end

        -- Create billboard GUI for clone
        local billboardGui = Instance.new('BillboardGui')
        billboardGui.Name = 'NameTag'
        billboardGui.Size = UDim2.new(0, 90, 0, 40)
        billboardGui.StudsOffset = Vector3.new(0, 2, 0)
        billboardGui.Adornee = head
        billboardGui.LightInfluence = 0
        billboardGui.AlwaysOnTop = true
        billboardGui.Parent = head
        -- No MaxDistance limit for infinite render distance

        local frame = Instance.new('Frame')
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1
        frame.BorderSizePixel = 0
        frame.Parent = billboardGui

        local characterLabel = Instance.new('TextLabel')
        characterLabel.Name = 'CharacterLabel'
        characterLabel.Size = UDim2.new(1, 0, 0.25, 0)
        characterLabel.Position = UDim2.new(0, 0, 0, 0)
        characterLabel.BackgroundTransparency = 1
        characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        characterLabel.TextScaled = false
        characterLabel.TextSize = 11
        characterLabel.TextStrokeTransparency = 0
        characterLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        characterLabel.Font = Enum.Font.SourceSans
        characterLabel.Parent = frame

        local usernameLabel = Instance.new('TextLabel')
        usernameLabel.Name = 'UsernameLabel'
        usernameLabel.Size = UDim2.new(1, 0, 0.25, 0)
        usernameLabel.Position = UDim2.new(0, 0, 0.35, 0) -- Increased from 0.25 to 0.35 for more spacing
        usernameLabel.BackgroundTransparency = 1
        usernameLabel.Text = '@' .. targetPlayer.Name .. ' (Dead)'
        usernameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        usernameLabel.TextScaled = true
        usernameLabel.TextStrokeTransparency = 0
        usernameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        usernameLabel.Font = Enum.Font.SourceSans
        usernameLabel.Parent = frame

        -- Get CharacterName attribute from the player
        local function updateCloneCharacterName()
            local customName = targetPlayer:GetAttribute('CharacterName')
            if customName then
                characterLabel.Text = 'üíÄ ' .. customName .. ' üíÄ'
                characterLabel.TextColor3 = characterColors[customName]
                    or Color3.fromRGB(255, 255, 255)
            else
                characterLabel.Text = 'üíÄ ' .. targetPlayer.Name .. ' üíÄ'
                characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        end

        updateCloneCharacterName()

        -- Listen for attribute changes on the player and track the connection
        if not cloneConnections[cloneModel] then
            cloneConnections[cloneModel] = {}
        end

        cloneConnections[cloneModel].attributeConn = targetPlayer.AttributeChanged:Connect(
            function(attributeName)
                if attributeName == 'CharacterName' then
                    updateCloneCharacterName()
                end
            end
        )

        -- Cleanup connection when clone is removed
        cloneConnections[cloneModel].ancestryConn = cloneModel.AncestryChanged:Connect(
            function(_, parent)
                if not parent then
                    -- Clone was removed, cleanup connections
                    local conns = cloneConnections[cloneModel]
                    if conns then
                        if conns.attributeConn then
                            conns.attributeConn:Disconnect()
                        end
                        if conns.ancestryConn then
                            conns.ancestryConn:Disconnect()
                        end
                        cloneConnections[cloneModel] = nil
                    end
                end
            end
        )
    end

    -- Monitor playerCloneFolder for new clones
    local function setupCloneFolderMonitoring()
        local cloneFolder = workspace:FindFirstChild('playerCloneFolder')
        if cloneFolder then
            -- Process existing clones
            for _, clone in ipairs(cloneFolder:GetChildren()) do
                if clone:IsA('Model') then
                    task.defer(function()
                        createCloneNameTag(clone)
                    end)
                end
            end

            -- Monitor for new clones
            local cloneAddedConn = cloneFolder.ChildAdded:Connect(
                function(clone)
                    if not _G.__ESP_ACTIVE or not _G.__DEAD_ESP_ENABLED then
                        return
                    end
                    if clone:IsA('Model') then
                        task.wait(0.05) -- Reduced from 0.1 to 0.05 for faster dead body ESP
                        createCloneNameTag(clone)
                    end
                end
            )
            table.insert(_G.__ESP_CONNECTIONS, cloneAddedConn)
        end
    end

    local playerRemovingConn = Players.PlayerRemoving:Connect(function(player)
        espCache[player.UserId] = nil
        playerNameCache[player.Name] = nil -- Clean up name cache
        friendCache[player] = nil -- Clean up friend cache
        local connections = playerConnections[player]
        if connections then
            for key, conn in pairs(connections) do
                if typeof(conn) == 'RBXScriptConnection' then
                    conn:Disconnect()
                end
                connections[key] = nil
            end
            playerConnections[player] = nil
        end
    end)
    table.insert(_G.__ESP_CONNECTIONS, playerRemovingConn)

    local playerAddedConn = Players.PlayerAdded:Connect(onPlayerAdded)
    table.insert(_G.__ESP_CONNECTIONS, playerAddedConn)

    task.spawn(function()
        local existingPlayers = Players:GetPlayers()
        for i, player in ipairs(existingPlayers) do
            if player ~= Players.LocalPlayer then
                onPlayerAdded(player)
            end
            if i % 3 == 0 then
                task.wait(0.05) -- Stagger initialization to reduce FPS spike
            end
        end
    end)

    -- Setup clone folder monitoring
    setupCloneFolderMonitoring()

    scanForItems()

    local lastItemScanTime = 0
    task.spawn(function()
        while _G.__ESP_ACTIVE do
            task.wait(MAINTENANCE_INTERVAL)
            -- Only check for missing ESP on live players (NO DISTANCE CHECK)
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer then
                    local character = player.Character
                    if character then
                        local head = character:FindFirstChild('Head')
                        -- Create ESP if missing, regardless of distance
                        if head and not head:FindFirstChild('NameTag') then
                            createNameTag(player, character)
                        end
                    end
                end
            end

            -- Dead body ESP is now handled entirely by ChildAdded monitoring
            -- No need to scan clones here - removes major FPS drop

            -- Check for missing dead ESP
            if _G.__DEAD_ESP_ENABLED then
                local playerCloneFolder =
                    workspace:FindFirstChild('playerCloneFolder')
                if playerCloneFolder then
                    for _, clone in pairs(playerCloneFolder:GetChildren()) do
                        if clone:IsA('Model') then
                            local head = clone:FindFirstChild('Head')
                            if head and not head:FindFirstChild('NameTag') then
                                createCloneNameTag(clone)
                            end
                        end
                    end
                end
            end

            -- Throttle item scanning to every other maintenance cycle
            local now = tick()
            if now - lastItemScanTime >= MAINTENANCE_INTERVAL * 2 then
                scanForItems()
                lastItemScanTime = now
            end
        end
    end)
end)

-- Dead ESP Toggle (Standalone System)
local DeadESPToggle = ESPTab:AddToggle('DeadESP', {
    Title = 'Show Dead Players',
    Default = false,
})

-- Dead ESP state (GLOBAL for obfuscation resistance)
_G.__DEAD_ESP_ENABLED = false
_G.__DEAD_ESP_CONNECTION = nil
_G.__DEAD_ESP_LOOP = nil

-- Character colors for dead ESP (GLOBAL)
_G.__DEAD_ESP_COLORS = {
    ['Silas'] = Color3.fromRGB(128, 0, 128),
    ['Bonnie Bennett'] = Color3.fromRGB(181, 101, 29),
    ['Hope Mikaelson'] = Color3.fromRGB(255, 0, 0),
    ['Esther Mikaelson'] = Color3.fromRGB(0, 0, 0),
    ['Davina Claire'] = Color3.fromRGB(0, 255, 0),
    ['Cleo Sowande'] = Color3.fromRGB(255, 255, 0),
    ['Landon Kirby'] = Color3.fromRGB(255, 165, 0),
    ['Dark Josie'] = Color3.fromRGB(160, 32, 240),
    ['Qetsiyah'] = Color3.fromRGB(0, 150, 255),
}

-- Function to create dead ESP (GLOBAL for obfuscation resistance)
_G.__CREATE_DEAD_ESP = function(cloneModel)
    if not _G.__DEAD_ESP_ENABLED then
        print('[Dead ESP] Not enabled, skipping')
        return
    end

    if not cloneModel or not cloneModel.Parent then
        print('[Dead ESP] Invalid clone model')
        return
    end

    local head = cloneModel:FindFirstChild('Head')
    if not head then
        print('[Dead ESP] No head found for', cloneModel.Name)
        return
    end

    if head:FindFirstChild('DeadESP') then
        print('[Dead ESP] ESP already exists for', cloneModel.Name)
        return
    end

    print('[Dead ESP] Creating ESP for', cloneModel.Name)

    -- Get player name from model name
    local playerName = cloneModel.Name

    -- Try to find the player (they might still be in game or might have left)
    local targetPlayer = game.Players:FindFirstChild(playerName)

    -- If player not found, create basic ESP without attribute tracking
    local hasPlayer = targetPlayer ~= nil

    -- Create billboard GUI
    local billboardGui = Instance.new('BillboardGui')
    billboardGui.Name = 'DeadESP'
    billboardGui.Size = UDim2.new(0, 90, 0, 40)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.Adornee = head
    billboardGui.LightInfluence = 0
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = head

    local frame = Instance.new('Frame')
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    frame.Parent = billboardGui

    local characterLabel = Instance.new('TextLabel')
    characterLabel.Name = 'CharacterLabel'
    characterLabel.Size = UDim2.new(1, 0, 0.5, 0)
    characterLabel.Position = UDim2.new(0, 0, 0, 0)
    characterLabel.BackgroundTransparency = 1
    characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    characterLabel.TextScaled = false
    characterLabel.TextSize = 14
    characterLabel.TextStrokeTransparency = 0
    characterLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    characterLabel.Font = Enum.Font.SourceSansBold
    characterLabel.Parent = frame

    local usernameLabel = Instance.new('TextLabel')
    usernameLabel.Name = 'UsernameLabel'
    usernameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    usernameLabel.Position = UDim2.new(0, 0, 0.5, 0)
    usernameLabel.BackgroundTransparency = 1
    usernameLabel.Text = '@' .. playerName .. ' (Dead)'
    usernameLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    usernameLabel.TextScaled = false
    usernameLabel.TextSize = 12
    usernameLabel.TextStrokeTransparency = 0
    usernameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    usernameLabel.Font = Enum.Font.SourceSans
    usernameLabel.Parent = frame

    -- Get character name from player attributes
    local function updateCharacterName()
        if hasPlayer and targetPlayer then
            local characterName = targetPlayer:GetAttribute('CharacterName')
            if characterName then
                characterLabel.Text = 'üíÄ ' .. characterName .. ' üíÄ'
                characterLabel.TextColor3 = _G.__DEAD_ESP_COLORS[characterName]
                    or Color3.fromRGB(255, 255, 255)
            else
                characterLabel.Text = 'üíÄ ' .. playerName .. ' üíÄ'
                characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        else
            -- Player left, just show their name
            characterLabel.Text = 'üíÄ ' .. playerName .. ' üíÄ'
            characterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end

    updateCharacterName()

    -- Listen for attribute changes only if player exists
    if hasPlayer and targetPlayer then
        local attrConn = targetPlayer.AttributeChanged:Connect(function(attr)
            if attr == 'CharacterName' and _G.__DEAD_ESP_ENABLED then
                updateCharacterName()
            end
        end)

        -- Cleanup when ESP is removed
        billboardGui.AncestryChanged:Connect(function(_, parent)
            if not parent then
                attrConn:Disconnect()
            end
        end)
    end
end

-- Function to remove all dead ESP
local function removeAllDeadESP()
    local playerCloneFolder = workspace:FindFirstChild('playerCloneFolder')
    if not playerCloneFolder then
        return
    end

    for _, clone in pairs(playerCloneFolder:GetChildren()) do
        local head = clone:FindFirstChild('Head')
        if head then
            local esp = head:FindFirstChild('DeadESP')
            if esp then
                esp:Destroy()
            end
        end
    end
end

DeadESPToggle:OnChanged(function(Value)
    _G.__DEAD_ESP_ENABLED = Value
    print('[Dead ESP] Toggle changed to:', Value)

    if Value then
        -- Create ESP for all existing dead players
        local playerCloneFolder = workspace:FindFirstChild('playerCloneFolder')
        if not playerCloneFolder then
            print('[Dead ESP] playerCloneFolder not found!')
            return
        end

        print(
            '[Dead ESP] Found playerCloneFolder with',
            #playerCloneFolder:GetChildren(),
            'children'
        )

        if playerCloneFolder then
            for _, clone in pairs(playerCloneFolder:GetChildren()) do
                if clone:IsA('Model') then
                    print('[Dead ESP] Processing clone:', clone.Name)
                    _G.__CREATE_DEAD_ESP(clone)
                end
            end

            -- Monitor for new dead players (using global function)
            _G.__DEAD_ESP_CONNECTION = playerCloneFolder.ChildAdded:Connect(
                function(clone)
                    print(
                        '[Dead ESP] ChildAdded fired for:',
                        clone.Name,
                        'Type:',
                        clone.ClassName
                    )
                    if not _G.__DEAD_ESP_ENABLED then
                        print('[Dead ESP] ESP is disabled, ignoring new child')
                        return
                    end

                    if clone:IsA('Model') then
                        print(
                            '[Dead ESP] New dead player detected:',
                            clone.Name
                        )
                        task.wait(0.1) -- Wait for model to fully load
                        if _G.__CREATE_DEAD_ESP then
                            _G.__CREATE_DEAD_ESP(clone)
                        else
                            warn('[Dead ESP] Global function not found!')
                        end
                    else
                        print('[Dead ESP] Child is not a Model, ignoring')
                    end
                end
            )

            print('[Dead ESP] ChildAdded monitoring active')

            -- Start polling loop as backup (checks every 3 seconds)
            _G.__DEAD_ESP_LOOP = task.spawn(function()
                while _G.__DEAD_ESP_ENABLED do
                    task.wait(3)
                    if not _G.__DEAD_ESP_ENABLED then
                        break
                    end

                    local folder = workspace:FindFirstChild('playerCloneFolder')
                    if folder then
                        for _, clone in pairs(folder:GetChildren()) do
                            if clone:IsA('Model') then
                                local head = clone:FindFirstChild('Head')
                                if
                                    head and not head:FindFirstChild('DeadESP')
                                then
                                    print(
                                        '[Dead ESP] Loop found missing ESP for:',
                                        clone.Name
                                    )
                                    if _G.__CREATE_DEAD_ESP then
                                        _G.__CREATE_DEAD_ESP(clone)
                                    end
                                end
                            end
                        end
                    end
                end
                print('[Dead ESP] Polling loop stopped')
            end)
        end

        if not isInitializing then
            Fluent:Notify({
                Title = 'Dead ESP',
                Content = 'Enabled - Dead players will now show',
                Duration = 2,
            })
        end
    else
        -- Disconnect monitoring
        if _G.__DEAD_ESP_CONNECTION then
            _G.__DEAD_ESP_CONNECTION:Disconnect()
            _G.__DEAD_ESP_CONNECTION = nil
        end

        -- Remove all dead ESP
        removeAllDeadESP()

        if not isInitializing then
            Fluent:Notify({
                Title = 'Dead ESP',
                Content = 'Disabled',
                Duration = 2,
            })
        end
    end
end)

-- Hitbox expander feature removed as requested

local TeleportTab = Window:AddTab({ Title = 'Teleports', Icon = 'map-pin' })
-- Remotes tab is created here so that it appears third in the sidebar.
local RemotesTab = Window:AddTab({ Title = 'Remotes', Icon = 'radio' })
-- Misc tab will appear last among the functional tabs.
local MiscTab = Window:AddTab({ Title = 'Misc', Icon = 'settings' })

-- ‚ö° AUTOFARM TAB ‚ö°
local AutofarmTab = Window:AddTab({ Title = 'Autofarm', Icon = 'droplet' })

AutofarmTab:AddParagraph({
    Title = 'Blood Bag Collection',
    Content = 'Automatically teleport to fridges and collect blood bags',
})

-- Blood bag collection variables
local bloodBagCollectionActive = false
local bloodBagCollectionThread = nil

-- Blood bag collection toggle
local BloodBagToggle = AutofarmTab:AddToggle('AutoCollectBloodBags', {
    Title = 'Auto Collect Blood Bags',
    Default = false,
})

BloodBagToggle:OnChanged(function(value)
    bloodBagCollectionActive = value
    _G.collectBloodBags = value

    if value then
        Fluent:Notify({
            Title = 'Auto Collect Blood Bags',
            Content = 'Blood bag collection started!',
            Duration = 3,
        })

        -- Start collection in a separate thread
        bloodBagCollectionThread = task.spawn(function()
            local TweenService = game:GetService('TweenService')
            local Players = game:GetService('Players')

            local player = Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild('HumanoidRootPart')

            local fridgesFolder = workspace.Interactables.Fridges
            local fridges = fridgesFolder:GetChildren()

            -- Tween settings
            local tweenInfo = TweenInfo.new(
                1, -- Duration in seconds
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.Out,
                0, -- Repeat count
                false, -- Reverse
                0 -- Delay
            )

            local function tweenToPosition(targetPosition)
                if not _G.collectBloodBags then
                    return
                end
                local tween = TweenService:Create(
                    humanoidRootPart,
                    tweenInfo,
                    { CFrame = CFrame.new(targetPosition) }
                )

                tween:Play()
                tween.Completed:Wait()
            end

            local function spamAllProximityPrompts(prompts, duration)
                local endTime = tick() + duration
                while tick() < endTime and _G.collectBloodBags do
                    -- Fire all prompts at once
                    for _, promptData in ipairs(prompts) do
                        fireproximityprompt(promptData.prompt)
                    end
                    task.wait(0.01) -- Wait between volleys
                end
            end

            print('Starting blood bag collection...')

            -- Continuous loop controlled by _G variable
            while _G.collectBloodBags do
                -- Loop through all fridges
                for index, fridge in ipairs(fridges) do
                    if not _G.collectBloodBags then
                        break
                    end

                    local success, err = pcall(function()
                        -- Get the fridge model position
                        if fridge:IsA('Model') and fridge.PrimaryPart then
                            local fridgePos = fridge.PrimaryPart.Position
                            local targetPos = fridgePos + Vector3.new(0, 10, 0) -- 10 studs above the model

                            print(
                                string.format(
                                    'Teleporting to fridge %d/%d...',
                                    index,
                                    #fridges
                                )
                            )

                            -- Tween to the fridge
                            tweenToPosition(targetPos)
                        elseif fridge:IsA('Model') then
                            -- If no PrimaryPart, get the center of the model's bounding box
                            local cf, size = fridge:GetBoundingBox()
                            local targetPos = cf.Position
                                + Vector3.new(0, size.Y / 2 + 5, 0)

                            print(
                                string.format(
                                    'Teleporting to fridge %d/%d...',
                                    index,
                                    #fridges
                                )
                            )

                            -- Tween to the fridge
                            tweenToPosition(targetPos)

                            -- Wait a moment for the game to register position
                            task.wait(0.2)

                            -- Now check if this fridge has any blood bags
                            local itemSpawns =
                                fridge:FindFirstChild('ItemSpawns')
                            local bloodBagPrompts = {}

                            if itemSpawns then
                                -- Check all spawn points (1, 2, 3, etc.) for blood bags
                                for _, spawnPoint in
                                    pairs(itemSpawns:GetChildren())
                                do
                                    local bloodBag =
                                        spawnPoint:FindFirstChild('BloodBag')
                                    if bloodBag then
                                        local toolPrompt =
                                            bloodBag:FindFirstChild(
                                                'ToolPrompt'
                                            )
                                        if
                                            toolPrompt
                                            and toolPrompt:IsA(
                                                'ProximityPrompt'
                                            )
                                        then
                                            table.insert(bloodBagPrompts, {
                                                prompt = toolPrompt,
                                                name = spawnPoint.Name,
                                            })
                                        end
                                    end
                                end
                            end

                            -- If blood bags found, spam the prompts
                            if #bloodBagPrompts > 0 then
                                print(
                                    string.format(
                                        'Collecting %d blood bags from fridge %d...',
                                        #bloodBagPrompts,
                                        index
                                    )
                                )
                                for _, promptData in ipairs(bloodBagPrompts) do
                                    print(
                                        string.format(
                                            '  - Found spawn point %s',
                                            promptData.name
                                        )
                                    )
                                end
                                spamAllProximityPrompts(bloodBagPrompts, 2) -- Spam all for 2 seconds
                            else
                                print(
                                    string.format(
                                        'No blood bags at fridge %d',
                                        index
                                    )
                                )
                            end

                            task.wait(0.2) -- Wait before moving to next fridge
                        else
                            warn(
                                string.format(
                                    'Fridge %d is not a valid model',
                                    index
                                )
                            )
                        end
                    end)

                    if not success then
                        warn(
                            string.format(
                                'Error processing fridge %d: %s',
                                index,
                                err
                            )
                        )
                    end
                end

                if _G.collectBloodBags then
                    print('Completed one cycle, restarting...')
                    task.wait(1) -- Small delay before restarting the cycle
                end
            end

            print('Blood bag collection stopped!')
        end)
    else
        Fluent:Notify({
            Title = 'Auto Collect Blood Bags',
            Content = 'Blood bag collection stopped!',
            Duration = 3,
        })

        -- Stop the collection thread
        if bloodBagCollectionThread then
            task.cancel(bloodBagCollectionThread)
            bloodBagCollectionThread = nil
        end
    end
end)

-- ‚ö° AUTO-DEPLOY SYSTEM ‚ö°
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local lp = Players.LocalPlayer
local spawnFunc, confirmFunc, yesFunc
local heartbeatConn
local running = false
local charAddedConn
local isInitialized = false
local initializationJobActive = false
local cachedSpawnFunc, cachedConfirmFunc, cachedYesFunc = nil, nil, nil
local CONFIRM_SPAM_COUNT = 12000
local HEARTBEAT_SPAM_COUNT = 6000

-- helper to safely get function name info
local getInfo = debug and debug.getinfo or getinfo

-- Wait for game to be fully loaded
if not game:IsLoaded() then
    print('[AUTO-DEPLOY] Waiting for game to load...')
    game.Loaded:Wait()
    task.wait(0.05) -- Extra buffer for safety
    print('[AUTO-DEPLOY] Game loaded!')
end

-- Initialize function scanner (ULTRA-OPTIMIZED for obfuscated code)
local function initializeAutoDeployFunctions(force)
    if initializationJobActive and not force then
        return
    end
    if initializationJobActive then
        return
    end
    initializationJobActive = true
    spawnFunc, confirmFunc, yesFunc = nil, nil, nil

    task.spawn(function()
        print('[AUTO-DEPLOY] Starting optimized GC scan...')
        local startTime = tick()
        local gc = getgc and getgc(true) or {}
        local totalItems = #gc
        print('[AUTO-DEPLOY] Scanning ' .. totalItems .. ' items in GC...')

        -- Store ALL instances
        local spawnFuncs = {}
        local confirmFuncs = {}
        local yesFuncs = {}

        -- OPTIMIZATION: Process in larger batches with less frequent yields
        local BATCH_SIZE = 10000 -- Process 10k items before yielding
        local foundAll = false

        for batchStart = 1, totalItems, BATCH_SIZE do
            if foundAll then
                break
            end

            local batchEnd = math.min(batchStart + BATCH_SIZE - 1, totalItems)

            -- Process entire batch without yielding
            for i = batchStart, batchEnd do
                local v = gc[i]
                if type(v) == 'function' then
                    local ok, info = pcall(getInfo, v)
                    if ok and info and info.name then
                        if info.name == 'spawnButtonActivated' then
                            table.insert(spawnFuncs, v)
                            print(
                                '[GC] Found spawnButtonActivated #'
                                    .. #spawnFuncs
                                    .. ' at index '
                                    .. i
                            )
                        elseif info.name == 'confirmPressed' then
                            table.insert(confirmFuncs, v)
                            print(
                                '[GC] Found confirmPressed #'
                                    .. #confirmFuncs
                                    .. ' at index '
                                    .. i
                            )
                        elseif info.name == 'yesButtonActivated' then
                            table.insert(yesFuncs, v)
                            print(
                                '[GC] Found yesButtonActivated #'
                                    .. #yesFuncs
                                    .. ' at index '
                                    .. i
                            )
                        end

                        -- OPTIMIZATION: Break early if all 3 functions found
                        if
                            #spawnFuncs > 0
                            and #confirmFuncs > 0
                            and #yesFuncs > 0
                        then
                            print(
                                '[AUTO-DEPLOY] All required functions found at index '
                                    .. i
                                    .. '/'
                                    .. totalItems
                                    .. ' - stopping scan early'
                            )
                            foundAll = true
                            break
                        end
                    end
                end
            end

            -- Only yield after processing entire batch (much less frequent)
            if not foundAll and batchEnd < totalItems then
                task.wait() -- Minimal yield to prevent timeout
            end
        end

        print(
            '[AUTO-DEPLOY] Scan complete - Found '
                .. #spawnFuncs
                .. ' spawn, '
                .. #confirmFuncs
                .. ' confirm, '
                .. #yesFuncs
                .. ' yes functions'
        )

        -- Try ALL instances - create a wrapper that calls all of them
        if #spawnFuncs > 0 then
            local allSpawns = spawnFuncs
            spawnFunc = function()
                for i, func in ipairs(allSpawns) do
                    pcall(func)
                end
            end
            print(
                '[AUTO-DEPLOY] Created spawn wrapper calling ALL '
                    .. #spawnFuncs
                    .. ' instances'
            )
        end

        if #confirmFuncs > 0 then
            local allConfirms = confirmFuncs
            confirmFunc = function()
                for i, func in ipairs(allConfirms) do
                    pcall(func)
                end
            end
            print(
                '[AUTO-DEPLOY] Created confirm wrapper calling ALL '
                    .. #confirmFuncs
                    .. ' instances'
            )
        end

        if #yesFuncs > 0 then
            local allYes = yesFuncs
            yesFunc = function()
                for i, func in ipairs(allYes) do
                    pcall(func)
                end
            end
            print(
                '[AUTO-DEPLOY] Created yes wrapper calling ALL '
                    .. #yesFuncs
                    .. ' instances'
            )
        end

        local scanTime = tick() - startTime
        print(
            '[AUTO-DEPLOY] GC scan completed in '
                .. string.format('%.2f', scanTime)
                .. ' seconds'
        )

        if not spawnFunc then
            warn('spawnButtonActivated not found in getgc')
        else
            print('[GC] spawnFunc ready')
        end
        if not confirmFunc then
            warn('confirmPressed not found in getgc')
        else
            print('[GC] confirmFunc ready')
        end
        if not yesFunc then
            warn(
                'yesButtonActivated not found in getgc - will spam all three anyway'
            )
        else
            print('[GC] yesFunc ready')
        end
        -- Set initialization state only when both spawn and confirm functions are found.
        -- If either is missing, leave isInitialized false so that the script can retry
        -- scanning on the next attempt. This prevents premature starts when
        -- functions haven‚Äôt been loaded yet and avoids missing confirmations.
        if spawnFunc and confirmFunc then
            isInitialized = true
            cachedSpawnFunc = spawnFunc
            cachedConfirmFunc = confirmFunc
            cachedYesFunc = yesFunc
            print('[AUTO-DEPLOY] Initialization complete!')
        else
            isInitialized = false
            print(
                '[AUTO-DEPLOY] Initialization incomplete; will retry on next toggle.'
            )
        end
        initializationJobActive = false
    end)
end

-- NO initial scan - only scan when J is pressed
-- This prevents issues if script is executed too early
print('[AUTO-DEPLOY] Ready. Press J to scan and deploy.')

-- stop function (disconnect heartbeat and char listener)
local function stopSpammer(reason)
    if heartbeatConn then
        heartbeatConn:Disconnect()
        heartbeatConn = nil
    end
    if charAddedConn then
        charAddedConn:Disconnect()
        charAddedConn = nil
    end
    if colorCheckConnection then
        colorCheckConnection:Disconnect()
        colorCheckConnection = nil
    end
    running = false
    isWaiting = false

    if reason then
        print('Auto-deploy stopped:', reason)
    else
        print('Auto-deploy stopped')
    end

    -- Update status label IMMEDIATELY when stopping
    if StatusLabel then
        UpdateStatus('Status: Inactive')
    end

    -- Only show notification if not a silent stop
    if reason and reason ~= 'silent' then
        Fluent:Notify({
            Title = '‚ö° Auto Deploy Stopped',
            Content = reason or 'Deactivated',
            Duration = 2,
        })
    end

    -- Re-initialize functions after stopping regardless of the reason.
end

-- start function (connect Heartbeat and CharacterAdded)
local function startSpammer()
    if running then
        return
    end

    -- Always refresh functions before each attempt to avoid stale references
    if heartbeatConn then
        heartbeatConn:Disconnect()
        heartbeatConn = nil
    end

    -- Use cached functions if available
    if cachedSpawnFunc and cachedConfirmFunc then
        spawnFunc, confirmFunc, yesFunc =
            cachedSpawnFunc, cachedConfirmFunc, cachedYesFunc
    else
        warn(
            '[AUTO-DEPLOY] Cached functions not available, triggering reinitialization...'
        )
        initializeAutoDeployFunctions(true)
    end

    local waited = 0
    local timeout = 1.5
    while waited < timeout and not (spawnFunc and confirmFunc) do
        if spawnFunc and confirmFunc then
            break
        end
        if cachedSpawnFunc and cachedConfirmFunc then
            spawnFunc = cachedSpawnFunc
            confirmFunc = cachedConfirmFunc
            yesFunc = cachedYesFunc
            break
        end
        task.wait(0.01)
        waited = waited + 0.01
    end

    if not (spawnFunc and confirmFunc) then
        if cachedSpawnFunc and cachedConfirmFunc then
            spawnFunc = cachedSpawnFunc
            confirmFunc = cachedConfirmFunc
            yesFunc = cachedYesFunc
            print(
                '[AUTO-DEPLOY] Using cached functions while refresh completes...'
            )
        else
            warn(
                'Required auto-deploy functions not ready after reinitialization'
            )
            Fluent:Notify({
                Title = '‚ùå Auto Deploy Failed',
                Content = 'Auto deploy functions not ready. Please wait and try again.',
                Duration = 3,
            })
            return
        end
    end

    -- Comprehensive UI checks before starting
    local uiReady = false
    local maxAttempts = 10
    local attempts = 0

    while not uiReady and attempts < maxAttempts do
        attempts = attempts + 1
        local success = pcall(function()
            -- Check if PlayerGui exists
            if not lp.PlayerGui then
                error('PlayerGui not found')
            end

            -- Check if StartScreen exists
            local startScreen = lp.PlayerGui:FindFirstChild('StartScreen')
            if not startScreen then
                error('StartScreen not found')
            end

            -- Check if MainHolder exists
            local mainHolder = startScreen:FindFirstChild('MainHolder')
            if not mainHolder then
                error('MainHolder not found')
            end

            -- Check if SelectCharacterFrame exists and is visible
            local selectFrame =
                mainHolder:FindFirstChild('SelectCharacterFrame')
            if not selectFrame or not selectFrame.Visible then
                error('SelectCharacterFrame not ready')
            end

            -- Check if spawn button exists
            local spawn =
                selectFrame.LeftArea.BottomArea:FindFirstChild('Spawn')
            if not spawn then
                error('Spawn button not found')
            end

            -- Verify button is clickable (not grey)
            local color = spawn.ImageColor3
            local r, g, b =
                math.floor(color.R * 255),
                math.floor(color.G * 255),
                math.floor(color.B * 255)
            if r == 72 and g == 72 and b == 72 then
                error('Spawn button still grey')
            end

            uiReady = true
        end)

        if not uiReady then
            print(
                '[AUTO-DEPLOY] UI not ready, attempt '
                    .. attempts
                    .. '/'
                    .. maxAttempts
            )
            task.wait(0.01)
        end
    end

    if not uiReady then
        Fluent:Notify({
            Title = '‚ùå Auto Deploy Failed',
            Content = 'UI not ready after ' .. maxAttempts .. ' attempts',
            Duration = 3,
        })
        return
    end

    -- Get the character name from ContentText
    local characterName = 'Unknown'
    pcall(function()
        characterName =
            lp.PlayerGui.StartScreen.MainHolder.CharacterInfo.PlayerName.ContentText
    end)

    Fluent:Notify({
        Title = '‚ö° Deploying as...',
        Content = characterName,
        Duration = 3,
        Image = 4483362458,
    })

    -- stop automatically when character spawns (silently)
    if lp then
        charAddedConn = lp.CharacterAdded:Connect(function(char)
            print('[AUTO-DEPLOY] Character spawned - stopping everything')

            -- Stop IMMEDIATELY
            running = false
            isWaiting = false

            -- Disconnect heartbeat FIRST
            if heartbeatConn then
                heartbeatConn:Disconnect()
                heartbeatConn = nil
            end
            if charAddedConn then
                charAddedConn:Disconnect()
                charAddedConn = nil
            end
            if colorCheckConnection then
                colorCheckConnection:Disconnect()
                colorCheckConnection = nil
            end

            -- Wait for character to fully load
            char:WaitForChild('Humanoid', 2)
            task.wait(0.2)

            -- Get character name
            local spawnedCharName = characterName
            pcall(function()
                local pg = lp:FindFirstChild('PlayerGui')
                if pg and pg:FindFirstChild('StartScreen') then
                    spawnedCharName =
                        pg.StartScreen.MainHolder.CharacterInfo.PlayerName.ContentText
                end
            end)

            -- Update status with character name - force multiple times
            for i = 1, 3 do
                if StatusLabel then
                    UpdateStatus('Status: Spawned as ' .. spawnedCharName)
                end
                task.wait(0.1)
            end

            print(
                '[AUTO-DEPLOY] Status updated to: Spawned as '
                    .. spawnedCharName
            )
        end)
    end

    running = true

    -- Update status label immediately when starting
    if StatusLabel then
        UpdateStatus('Status: Active (one-shot)')
    end

    -- Confirm helper: try to press the visible Yes button once
    local lastYesClick = 0

    local function clickYesOnce()
        pcall(function()
            local mainHolder = lp.PlayerGui.StartScreen.MainHolder
            local confirmFrame = mainHolder
                and mainHolder:FindFirstChild('ConfirmFrame')
            if confirmFrame and confirmFrame.Visible then
                local yesButton = confirmFrame:FindFirstChild('Yes')
                if yesButton and yesButton.Visible then
                    if getconnections then
                        for _, connection in
                            pairs(getconnections(yesButton.MouseButton1Click))
                        do
                            pcall(function()
                                connection:Fire()
                            end)
                        end
                        for _, connection in
                            pairs(getconnections(yesButton.Activated))
                        do
                            pcall(function()
                                connection:Fire()
                            end)
                        end
                        lastYesClick = tick()
                    end
                end
            end
        end)
    end

    -- Helper: detect screen transition becoming active
    local function isScreenTransitionActive()
        local active = false
        pcall(function()
            local pg = lp:FindFirstChild('PlayerGui')
            local su = pg and pg:FindFirstChild('ScreenUtils')
            local st = su and su:FindFirstChild('ScreenTransition')
            if st and st.Active ~= nil then
                active = st.Active == true
            end
        end)
        if active and running then
            print(
                '[AUTO-DEPLOY] ScreenTransition detected - STOPPING EVERYTHING'
            )
            running = false
            isWaiting = false

            -- Disconnect all connections immediately
            if heartbeatConn then
                heartbeatConn:Disconnect()
                heartbeatConn = nil
            end
            if charAddedConn then
                charAddedConn:Disconnect()
                charAddedConn = nil
            end
            if colorCheckConnection then
                colorCheckConnection:Disconnect()
                colorCheckConnection = nil
            end

            -- Update status
            if StatusLabel then
                UpdateStatus('Status: Spawning...')
            end

            print(
                '[AUTO-DEPLOY] All connections stopped - spawn sequence detected'
            )
        end
        return active
    end

    -- Fire spawn exactly once, then immediately burst confirm before next frame
    if spawnFunc then
        print('[AUTO-DEPLOY] Firing spawn function...')
        pcall(spawnFunc)
    else
        warn('[AUTO-DEPLOY] spawnFunc is nil!')
    end

    if confirmFunc and running then
        print(
            '[AUTO-DEPLOY] Starting confirm spam ('
                .. CONFIRM_SPAM_COUNT
                .. ' times)...'
        )
        -- Instant burst to trigger confirm without waiting for Heartbeat
        for _ = 1, CONFIRM_SPAM_COUNT do
            if not running then
                break
            end
            pcall(confirmFunc)
        end
        print('[AUTO-DEPLOY] Confirm spam completed')
        -- Also try 'Yes' instantly
        if yesFunc and running then
            pcall(yesFunc)
        end
    else
        if not confirmFunc then
            warn('[AUTO-DEPLOY] confirmFunc is nil!')
        end
    end

    -- Status update removed - keep previous status during confirmation

    local startTime = tick()

    heartbeatConn = RunService.Heartbeat:Connect(function()
        -- CRITICAL: Stop immediately if not running
        if not running then
            if heartbeatConn then
                heartbeatConn:Disconnect()
                heartbeatConn = nil
            end
            return
        end

        local now = tick()

        -- Stop immediately if screen transition is active (spawn sequence)
        if isScreenTransitionActive() then
            return
        end

        -- Spam confirm as fast as possible (burst each frame)
        if confirmFunc and running then
            for _ = 1, HEARTBEAT_SPAM_COUNT do
                if not running then
                    break
                end
                pcall(confirmFunc)
            end
        end

        -- Try to hit 'Yes' every frame as well
        if yesFunc and running then
            pcall(yesFunc)
        end
        clickYesOnce()

        -- Safety timeout if no spawn occurred
        if (now - startTime) > 8 then
            stopSpammer('confirm timeout')
        end
    end)

    print(
        '[AUTO-DEPLOY] Spawn clicked once; spamming confirm at max rate until spawn or timeout'
    )
end

--
-- Synchronize the status label with the player's spawn state.
-- When the character spawns (regardless of how the auto deploy was
-- stopped), update the status label to "Spawned". This ensures
-- the UI accurately reflects the fact that you have spawned into the
-- game and avoids stale "waiting" messages lingering after a
-- successful deploy. We connect this handler once up front so it
-- always fires when the local character is added.
do
    local player = game:GetService('Players').LocalPlayer
    -- A separate connection outside of auto‚Äëdeploy ensures the label
    -- updates even if the auto‚Äëdeploy logic fails to change the label.
    player.CharacterAdded:Connect(function(character)
        if StatusLabel then
            -- Try to get character name from UI
            local charName = 'Unknown'
            pcall(function()
                local pg = player:FindFirstChild('PlayerGui')
                if pg then
                    local startScreen = pg:FindFirstChild('StartScreen')
                    if startScreen then
                        charName =
                            startScreen.MainHolder.CharacterInfo.PlayerName.ContentText
                    end
                end
            end)
            UpdateStatus('Status: Spawned as ' .. charName)
        end
    end)

    -- Monitor for character selection screen visibility
    task.spawn(function()
        while true do
            task.wait(3) -- Check every 3 seconds (reduced performance impact)

            -- Only update if not in any active auto-deploy process and not waiting
            if StatusLabel and not running and not isWaiting then
                -- Get current status to avoid overriding important states
                local currentStatus = StatusLabel.Content or ''

                -- Don't override if status contains "Waiting", "Spawning", "Active", or "Confirming"
                local shouldNotOverride = currentStatus:find('Waiting')
                    or currentStatus:find('Spawning')
                    or currentStatus:find('Active')
                    or currentStatus:find('Confirming')

                if not shouldNotOverride then
                    local pg = player:FindFirstChild('PlayerGui')
                    if pg then
                        local startScreen = pg:FindFirstChild('StartScreen')
                        if startScreen then
                            local mainHolder =
                                startScreen:FindFirstChild('MainHolder')
                            if mainHolder then
                                local selectFrame = mainHolder:FindFirstChild(
                                    'SelectCharacterFrame'
                                )
                                if selectFrame and selectFrame.Visible then
                                    -- Character selection screen is visible and status is idle
                                    UpdateStatus('Status: In lobby')
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

local AutoDeployButton = MainTab:AddButton({
    Title = 'Auto Deploy (J)',
    Callback = function()
        Fluent:Notify({
            Title = 'Auto Deploy',
            Content = 'Press J to toggle Auto Deploy',
            Duration = 2,
        })
    end,
})

-- toggle on J
local colorCheckConnection = nil
local isWaiting = false

-- Scope-safe lobby checker (doesn't rely on other locals)
local function InLobbySafe()
    local pg = LocalPlayer and LocalPlayer:FindFirstChild('PlayerGui')
    if pg then
        local names = {
            'StartScreen',
            'Lobby',
            'LobbyUI',
            'LobbyScreen',
            'Menu',
            'MainMenu',
        }
        for _, n in ipairs(names) do
            if pg:FindFirstChild(n) then
                return true
            end
        end
    end
    -- If no character or dead, treat as lobby/menu state
    local c = LocalPlayer and LocalPlayer.Character
    local h = c and c:FindFirstChildOfClass('Humanoid')
    if not (c and h and h.Health > 0) then
        return true
    end
    return false
end

-- Add debounce for J key to prevent spam
local lastJPress = 0
local J_DEBOUNCE = 0.5 -- 500ms cooldown

UserInputService.InputBegan:Connect(function(inp, gameProcessed)
    -- Ignore input if Roblox processed it or hotkeys are disabled
    if gameProcessed then
        return
    end
    if not hotkeysEnabled then
        return
    end
    -- Check for the J key after initialization
    if inp.KeyCode == Enum.KeyCode.J then
        -- Block J key until script is fully initialized
        if not _G.__SCRIPT_FULLY_INITIALIZED then
            Fluent:Notify({
                Title = 'Please Wait',
                Content = 'Script is still initializing... Please wait.',
                Duration = 2,
            })
            return
        end

        -- Debounce check
        local now = tick()
        if now - lastJPress < J_DEBOUNCE then
            return
        end
        lastJPress = now
        -- Spawn-safe guard: if already spawned, don't attempt lobby UI logic.
        -- Arm auto-deploy for the next time StartScreen/Lobby appears instead.
        do
            local char = LocalPlayer.Character
            local hum = char and char:FindFirstChildOfClass('Humanoid')
            if char and hum and hum.Health > 0 and not InLobbySafe() then
                -- Get character name
                local charName = 'Unknown'
                pcall(function()
                    local pg = LocalPlayer:FindFirstChild('PlayerGui')
                    if pg then
                        local startScreen = pg:FindFirstChild('StartScreen')
                        if startScreen then
                            charName =
                                startScreen.MainHolder.CharacterInfo.PlayerName.ContentText
                        end
                    end
                end)

                Fluent:Notify({
                    Title = 'Auto Deploy',
                    Content = 'You are already spawned. Auto‚Äëdeploy will arm for next lobby/respawn.',
                    Duration = 3,
                })
                if StatusLabel then
                    UpdateStatus('Status: Spawned as ' .. charName)
                end
                local pg = LocalPlayer:FindFirstChild('PlayerGui')
                if pg then
                    if _G.__AD_ArmConn then
                        pcall(function()
                            _G.__AD_ArmConn:Disconnect()
                        end)
                    end
                    _G.__AD_ArmConn = pg.ChildAdded:Connect(function(child)
                        if
                            child
                            and (
                                child.Name == 'StartScreen'
                                or child.Name == 'Lobby'
                                or child.Name == 'LobbyUI'
                                or child.Name == 'LobbyScreen'
                            )
                        then
                            if _G.__AD_ArmConn then
                                pcall(function()
                                    _G.__AD_ArmConn:Disconnect()
                                end)
                                _G.__AD_ArmConn = nil
                            end
                            task.delay(0.1, function()
                                local c = LocalPlayer.Character
                                local h = c
                                    and c:FindFirstChildOfClass('Humanoid')
                                -- Only start spammer if we are no longer spawned (i.e., back at lobby)
                                if not (c and h and h.Health > 0) then
                                    isWaiting = false
                                    if type(startSpammer) == 'function' then
                                        startSpammer()
                                    elseif
                                        type(StartAutoDeploy) == 'function'
                                    then
                                        StartAutoDeploy(true)
                                    end
                                end
                            end)
                        end
                    end)
                end
                return
            end
        end

        -- Verify game is fully loaded before scanning
        if not game:IsLoaded() then
            Fluent:Notify({
                Title = 'Auto Deploy',
                Content = 'Game is still loading. Please wait...',
                Duration = 3,
            })
            return
        end

        -- CRITICAL: Wait for character selection UI to be fully loaded
        print('[AUTO-DEPLOY] Waiting for UI to be ready...')
        local uiReady = false
        local maxUIWait = 10
        local uiWaited = 0

        while not uiReady and uiWaited < maxUIWait do
            local ok = pcall(function()
                local pg = lp:FindFirstChild('PlayerGui')
                local ss = pg and pg:FindFirstChild('StartScreen')
                local mh = ss and ss:FindFirstChild('MainHolder')
                local scf = mh and mh:FindFirstChild('SelectCharacterFrame')
                local spawn = scf
                    and scf:FindFirstChild('LeftArea')
                    and scf.LeftArea:FindFirstChild('BottomArea')
                    and scf.LeftArea.BottomArea:FindFirstChild('Spawn')

                if spawn then
                    uiReady = true
                end
            end)

            if not uiReady then
                task.wait(0.2)
                uiWaited = uiWaited + 0.2
                print('[AUTO-DEPLOY] Waiting for UI... (' .. uiWaited .. 's)')
            end
        end

        if not uiReady then
            Fluent:Notify({
                Title = 'Auto Deploy',
                Content = 'Character selection UI not ready. Please wait and try again.',
                Duration = 4,
            })
            print('[AUTO-DEPLOY] UI not ready after ' .. uiWaited .. ' seconds')
            return
        end

        print('[AUTO-DEPLOY] UI is ready! Starting GC scan...')
        task.wait(0.2) -- Extra wait to ensure functions are loaded into GC

        -- ALWAYS reinitialize on every J press (as requested)
        print(
            '[AUTO-DEPLOY] Reinitializing - scanning entire GC for functions...'
        )

        -- Reset and force new scan EVERY TIME
        isInitialized = false
        initializationJobActive = false
        spawnFunc = nil
        confirmFunc = nil
        yesFunc = nil

        -- Start the scan
        initializeAutoDeployFunctions(true)

        -- Wait for scan to complete (max 10 seconds for early execution)
        local maxWait = 10
        local waited = 0
        while
            (not isInitialized or not spawnFunc or not confirmFunc)
            and waited < maxWait
        do
            task.wait(0.1)
            waited = waited + 0.1

            -- Show progress every 2 seconds
            if waited % 2 == 0 then
                print('[AUTO-DEPLOY] Still scanning... (' .. waited .. 's)')
            end
        end

        -- Check if scan was successful
        if not isInitialized or not spawnFunc or not confirmFunc then
            Fluent:Notify({
                Title = 'Auto Deploy',
                Content = 'Functions not found. Game may not be ready. Wait and try again.',
                Duration = 4,
            })
            print(
                '[AUTO-DEPLOY] Scan failed - functions not found after '
                    .. waited
                    .. ' seconds'
            )
            print(
                '[AUTO-DEPLOY] This may happen if script was executed too early'
            )
            print('[AUTO-DEPLOY] Wait a few seconds and press J again')
            return
        end

        print('[AUTO-DEPLOY] Functions found! Starting deployment...')

        -- Check if waiting and cancel it
        if isWaiting then
            -- If already waiting, pressing J again cancels the wait
            print('[DEBUG] Cancelled waiting for button')
            Fluent:Notify({
                Title = '‚ùå Auto Deploy Cancelled',
                Content = 'Stopped waiting for button',
                Duration = 2,
            })
            if colorCheckConnection then
                colorCheckConnection:Disconnect()
                colorCheckConnection = nil
            end
            isWaiting = false
            UpdateStatus('Status: Inactive')
        else
            -- Enhanced checks before starting
            local success, errorMsg = pcall(function()
                -- First, verify the UI exists
                local startScreen = lp.PlayerGui:FindFirstChild('StartScreen')
                if not startScreen then
                    error(
                        'StartScreen not found - are you on the spawn screen?'
                    )
                end

                local mainHolder = startScreen:FindFirstChild('MainHolder')
                if not mainHolder then
                    error('MainHolder not found')
                end

                local selectFrame =
                    mainHolder:FindFirstChild('SelectCharacterFrame')
                if not selectFrame then
                    error(
                        'SelectCharacterFrame not found - you may not be on the character selection screen'
                    )
                end

                -- Check if the frame is actually visible
                if not selectFrame.Visible then
                    error('Character selection screen is not visible')
                end

                local spawn =
                    selectFrame.LeftArea.BottomArea:FindFirstChild('Spawn')
                if not spawn then
                    error('Spawn button not found in UI')
                end

                local color = spawn.ImageColor3
                local r, g, b =
                    math.floor(color.R * 255),
                    math.floor(color.G * 255),
                    math.floor(color.B * 255)

                print('[DEBUG] Current button color RGB:', r, g, b)

                -- Check if button is greyed out or dark (waiting for character to unlock)
                if
                    (r == 72 and g == 72 and b == 72)
                    or (r < 100 and g < 100 and b < 100)
                then
                    print(
                        '[DEBUG] Button is greyed out (RGB: '
                            .. r
                            .. ','
                            .. g
                            .. ','
                            .. b
                            .. ') - waiting for it to become available...'
                    )

                    local characterName = 'Unknown'
                    pcall(function()
                        characterName =
                            mainHolder.CharacterInfo.PlayerName.ContentText
                    end)

                    isWaiting = true
                    Fluent:Notify({
                        Title = '‚è≥ Auto Deploy',
                        Content = 'Waiting for '
                            .. characterName
                            .. ' to unlock...',
                        Duration = 3,
                    })
                    UpdateStatus(
                        'Status: Waiting for '
                            .. characterName
                            .. ' to unlock...'
                    )

                    local initialCharacterName = characterName
                    local spawnButton = selectFrame.LeftArea.BottomArea.Spawn

                    -- Use GetPropertyChangedSignal for INSTANT color detection
                    colorCheckConnection = spawnButton
                        :GetPropertyChangedSignal('ImageColor3')
                        :Connect(function()
                            -- CRITICAL: Check if character changed FIRST (before checking color)
                            local ok, currentName = pcall(function()
                                return lp.PlayerGui.StartScreen.MainHolder.CharacterInfo.PlayerName.ContentText
                            end)

                            if ok and currentName ~= initialCharacterName then
                                -- Character changed - STOP immediately
                                colorCheckConnection:Disconnect()
                                colorCheckConnection = nil
                                isWaiting = false
                                UpdateStatus('Status: Inactive')
                                task.defer(function()
                                    print(
                                        '[AUTO-DEPLOY] Character changed - stopping'
                                    )
                                    Fluent:Notify({
                                        Title = '‚ö†Ô∏è Character Changed',
                                        Content = 'Auto-deploy stopped',
                                        Duration = 2,
                                    })
                                end)
                                return
                            end

                            -- ULTRA-FAST: Single comparison check
                            local color = spawnButton.ImageColor3

                            -- Instant check - if R > 0.1, button is unlocked (single comparison = fastest)
                            if color.R > 0.1 then
                                -- Disconnect IMMEDIATELY
                                colorCheckConnection:Disconnect()
                                colorCheckConnection = nil
                                isWaiting = false

                                -- START SPAMMING INSTANTLY (no logging, no checks)
                                startSpammer()

                                -- Everything else happens async (non-blocking)
                                task.defer(function()
                                    print(
                                        '[AUTO-DEPLOY] Button unlocked - SPAMMING NOW'
                                    )
                                    Fluent:Notify({
                                        Title = '‚úÖ Deploying',
                                        Content = 'Button unlocked!',
                                        Duration = 1.5,
                                    })
                                end)
                                return
                            end

                            -- Check if UI still exists
                            if not selectFrame.Visible then
                                colorCheckConnection:Disconnect()
                                colorCheckConnection = nil
                                isWaiting = false
                                return
                            end
                        end)
                -- Check if button is bright/available (RGB 150+ indicates unlocked)
                elseif r >= 150 and g >= 150 and b >= 150 then
                    print(
                        '[DEBUG] Button is available (RGB: '
                            .. r
                            .. ','
                            .. g
                            .. ','
                            .. b
                            .. ') - starting auto-deploy'
                    )
                    Fluent:Notify({
                        Title = '‚úÖ Auto Deploy',
                        Content = 'Button ready - deploying now!',
                        Duration = 2,
                    })
                    startSpammer()
                else
                    -- Button in intermediate/loading state - treat as locked and wait
                    print(
                        '[DEBUG] Button in loading state (RGB: '
                            .. r
                            .. ','
                            .. g
                            .. ','
                            .. b
                            .. ') - waiting for unlock...'
                    )

                    local characterName = 'Unknown'
                    pcall(function()
                        characterName =
                            mainHolder.CharacterInfo.PlayerName.ContentText
                    end)

                    isWaiting = true
                    Fluent:Notify({
                        Title = '‚è≥ Auto Deploy',
                        Content = 'Waiting for '
                            .. characterName
                            .. ' to unlock...',
                        Duration = 3,
                    })
                    UpdateStatus(
                        'Status: Waiting for '
                            .. characterName
                            .. ' to unlock...'
                    )

                    local lastCheck = 0
                    local lastR, lastG, lastB = r, g, b
                    local initialCharacterName = characterName
                    colorCheckConnection = RunService.Heartbeat:Connect(
                        function()
                            local now = tick()
                            -- Throttle to 10 checks per second
                            if now - lastCheck < 0.1 then
                                return
                            end
                            lastCheck = now

                            -- Re-check if UI still exists
                            local currentSelectFrame =
                                lp.PlayerGui.StartScreen.MainHolder:FindFirstChild(
                                    'SelectCharacterFrame'
                                )
                            if
                                not currentSelectFrame
                                or not currentSelectFrame.Visible
                            then
                                print(
                                    '[DEBUG] Character selection screen closed, cancelling wait'
                                )
                                if colorCheckConnection then
                                    colorCheckConnection:Disconnect()
                                    colorCheckConnection = nil
                                end
                                isWaiting = false
                                UpdateStatus('Status: Screen Closed')
                                return
                            end

                            -- Check if character name changed
                            local currentCharacterName = 'Unknown'
                            pcall(function()
                                currentCharacterName =
                                    lp.PlayerGui.StartScreen.MainHolder.CharacterInfo.PlayerName.ContentText
                            end)
                            if currentCharacterName ~= initialCharacterName then
                                print(
                                    '[DEBUG] Character changed from '
                                        .. initialCharacterName
                                        .. ' to '
                                        .. currentCharacterName
                                        .. ', stopping auto-deploy'
                                )
                                if colorCheckConnection then
                                    colorCheckConnection:Disconnect()
                                    colorCheckConnection = nil
                                end
                                isWaiting = false
                                UpdateStatus('Status: Inactive')
                                Fluent:Notify({
                                    Title = '‚ö†Ô∏è Character Changed',
                                    Content = 'Auto-deploy stopped',
                                    Duration = 2,
                                })
                                return
                            end

                            local currentSpawn =
                                currentSelectFrame.LeftArea.BottomArea.Spawn
                            local currentColor = currentSpawn.ImageColor3
                            local newR, newG, newB =
                                math.floor(currentColor.R * 255),
                                math.floor(currentColor.G * 255),
                                math.floor(currentColor.B * 255)

                            if
                                newR ~= lastR
                                or newG ~= lastG
                                or newB ~= lastB
                            then
                                print(
                                    '[DEBUG] Color changed - RGB:',
                                    newR,
                                    newG,
                                    newB
                                )
                                lastR, lastG, lastB = newR, newG, newB

                                -- If color becomes bright (150+), button is unlocked
                                if
                                    newR >= 150
                                    and newG >= 150
                                    and newB >= 150
                                then
                                    print(
                                        '[DEBUG] Button unlocked! Starting auto-deploy...'
                                    )
                                    Fluent:Notify({
                                        Title = '‚úÖ Button Unlocked',
                                        Content = 'Starting auto-deploy now!',
                                        Duration = 2,
                                    })

                                    if colorCheckConnection then
                                        colorCheckConnection:Disconnect()
                                        colorCheckConnection = nil
                                    end

                                    isWaiting = false
                                    startSpammer()
                                end
                            end
                        end
                    )
                end
            end)

            if not success then
                print('[ERROR] Auto-deploy check failed:', errorMsg)
                Fluent:Notify({
                    Title = '‚ùå Error',
                    Content = tostring(errorMsg),
                    Duration = 4,
                })
                -- If the error indicates the character selection screen is missing or hidden,
                -- show a more descriptive status so the user knows why auto-deploy cannot start.
                local err = tostring(errorMsg)
                if
                    string.find(
                        err,
                        'Character selection screen is not visible',
                        1,
                        true
                    )
                    or string.find(
                        err,
                        'SelectCharacterFrame not found',
                        1,
                        true
                    )
                    or string.find(err, 'StartScreen not found', 1, true)
                    or string.find(err, 'MainHolder not found', 1, true)
                then
                    UpdateStatus('Status: Character menu not found')
                else
                    UpdateStatus('Status: Error')
                end
            end
        end
    end
end)

-- extra safety: if player already has a character, consider we have "spawned" and ensure not running
if lp and lp.Character then
    -- Stop silently without notification
    if heartbeatConn then
        heartbeatConn:Disconnect()
        heartbeatConn = nil
    end
    if charAddedConn then
        charAddedConn:Disconnect()
        charAddedConn = nil
    end
    running = false

    -- Get character name for status
    local charName = 'Unknown'
    pcall(function()
        local pg = lp:FindFirstChild('PlayerGui')
        if pg then
            local startScreen = pg:FindFirstChild('StartScreen')
            if startScreen then
                charName =
                    startScreen.MainHolder.CharacterInfo.PlayerName.ContentText
            end
        end
    end)
    UpdateStatus('Status: Spawned as ' .. charName)
end

print('Auto-deploy toggle ready ‚Äî Press J to start/stop.')

-- Hotkey Settings
_G.SelfAbilityHotkey = Enum.KeyCode.U

-- Wait 3 seconds before enabling hotkeys
-- Define hotkeysEnabled as a global so it is visible to the event callbacks
hotkeysEnabled = false

-- Wait 0.5 seconds before enabling hotkeys (reduced for faster startup)
task.delay(0.5, function()
    hotkeysEnabled = true
    print('[HOTKEYS] Hotkeys enabled!')
end) -- Removed Fast Respawn Hotkey (feature removed)

-- Helper function to convert key input to KeyCode
local function getKeyCode(input)
    local key = input:upper()

    -- Map number strings to their KeyCode names
    local numberMap = {
        ['0'] = 'Zero',
        ['1'] = 'One',
        ['2'] = 'Two',
        ['3'] = 'Three',
        ['4'] = 'Four',
        ['5'] = 'Five',
        ['6'] = 'Six',
        ['7'] = 'Seven',
        ['8'] = 'Eight',
        ['9'] = 'Nine',
    }

    -- Check if it's a number
    if numberMap[key] then
        return Enum.KeyCode[numberMap[key]]
    end

    -- Otherwise try as a letter
    return Enum.KeyCode[key]
end

-- Self Ability Hotkey
local SelfAbilityInput = MainTab:AddInput('SelfAbilityHotkey', {
    Title = 'Self Ability Hotkey',
    Default = 'U',
    Placeholder = 'U',
    Numeric = false,
    Finished = false,
})

SelfAbilityInput:OnChanged(function()
    local Text = SelfAbilityInput.Value
    local keyCode = getKeyCode(Text)
    if keyCode then
        _G.SelfAbilityHotkey = keyCode
        if not isInitializing then
            Fluent:Notify({
                Title = 'Hotkey Updated',
                Content = 'Self Ability hotkey set to: ' .. Text:upper(),
                Duration = 2,
            })
        end
    else
        Fluent:Notify({
            Title = 'Invalid Key',
            Content = 'Please enter a valid key (e.g., U, Y, H, 1-9)',
            Duration = 3,
        })
    end
end)

-- Fast Respawn Hotkey
-- (Fast Respawn Hotkey input removed)

-- Hotkey Handler
UserInputService.InputBegan:Connect(function(input, gp)
    -- Ignore input if Roblox processed it or hotkeys are disabled
    if gp then
        return
    end
    if not hotkeysEnabled then
        return
    end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then
        return
    end

    -- Self Ability hotkey
    if input.KeyCode == _G.SelfAbilityHotkey then
        local player = game:GetService('Players').LocalPlayer
        if player.Character then
            local args = {
                player.Character,
            }
            game:GetService('ReplicatedStorage')
                :WaitForChild('Remotes')
                :WaitForChild('AbilityService')
                :WaitForChild('ToServer')
                :WaitForChild('AbilityActivated___')
                :FireServer(unpack(args))
        end
    end

    -- Fast Respawn feature removed
end)

-- RemotesTab has already been created earlier to ensure the desired tab order.

-- ‚ö° UNDESICCATE SECTION ‚ö°
RemotesTab:AddParagraph({
    Title = 'Undesiccate',
    Content = 'Restore desiccated entities',
})

local Workspace = game:GetService('Workspace')
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local selectedEntity = nil
local entityLookup = {}

local function getDesiccatedEntities()
    entityLookup = {}
    local names = {}

    if Workspace:FindFirstChild('Entities') then
        for _, entity in pairs(Workspace.Entities:GetChildren()) do
            if entity:GetAttribute('Desiccated') == true then
                table.insert(names, entity.Name)
                entityLookup[entity.Name] = entity
            end
        end
    end

    table.sort(names)
    return names
end

local UndesiccateDropdown = RemotesTab:AddDropdown('UndesiccateDropdown', {
    Title = 'Select Desiccated Entity',
    Values = getDesiccatedEntities(),
    Multi = false,
    Default = 1,
})

UndesiccateDropdown:OnChanged(function(Value)
    local selected = type(Value) == 'table' and Value[1] or Value
    selectedEntity = tostring(selected)
    if not isInitializing then
        Fluent:Notify({
            Title = 'Entity Selected',
            Content = 'Target: ' .. selectedEntity,
            Duration = 2,
        })
    end
end)

local RefreshUndesiccateButton = RemotesTab:AddButton({
    Title = 'Refresh Entity List',
    Callback = function()
        local newList = getDesiccatedEntities()
        UndesiccateDropdown:SetValues(newList)

        Fluent:Notify({
            Title = 'Refreshed',
            Content = 'Entity list updated! Found: ' .. #newList,
            Duration = 2,
        })
    end,
})

local UndesiccateButton = RemotesTab:AddButton({
    Title = 'Undesiccate',
    Callback = function()
        if
            not selectedEntity
            or selectedEntity == ''
            or selectedEntity == 'None'
        then
            Fluent:Notify({
                Title = 'Error',
                Content = 'No entity selected!',
                Duration = 3,
            })
            return
        end

        local targetEntity = entityLookup[selectedEntity]

        if not targetEntity or not targetEntity.Parent then
            Fluent:Notify({
                Title = 'Error',
                Content = 'Entity not found or was removed!',
                Duration = 3,
            })
            return
        end

        if targetEntity:GetAttribute('Desiccated') ~= true then
            Fluent:Notify({
                Title = 'Error',
                Content = 'Entity is no longer desiccated!',
                Duration = 3,
            })
            return
        end

        local success, err = pcall(function()
            local args = { targetEntity }
            ReplicatedStorage.Remotes.ToolService.ToServer.ToolActivated:FireServer(
                unpack(args)
            )
        end)

        if success then
            Fluent:Notify({
                Title = 'Success',
                Content = 'Undesiccated ' .. selectedEntity,
                Duration = 3,
            })
        else
            Fluent:Notify({
                Title = 'Failed',
                Content = 'Error: ' .. tostring(err),
                Duration = 4,
            })
        end
    end,
})

-- ‚ö° REMOTE RESURRECTION SECTION ‚ö°
RemotesTab:AddParagraph({
    Title = 'Remote Resurrection',
    Content = 'Resurrect players in limbo',
})

local selectedPlayer = nil
local playerLookup = {}

local function getLimboPlayers()
    playerLookup = {}
    local names = {}

    if Workspace:FindFirstChild('playerInLimboFolder') then
        for _, playerModel in pairs(Workspace.playerInLimboFolder:GetChildren()) do
            if playerModel:IsA('Model') then
                local playerName = playerModel.Name
                table.insert(names, playerName)
                playerLookup[playerName] = playerModel
            end
        end
    end

    table.sort(names)
    return names
end

local ResurrectionDropdown = RemotesTab:AddDropdown('ResurrectionDropdown', {
    Title = 'Select Player in Limbo',
    Values = getLimboPlayers(),
    Multi = false,
    Default = 1,
})

ResurrectionDropdown:OnChanged(function(Value)
    local selected = type(Value) == 'table' and Value[1] or Value
    selectedPlayer = tostring(selected)
    if not isInitializing then
        Fluent:Notify({
            Title = 'Player Selected',
            Content = 'Target: ' .. selectedPlayer,
            Duration = 2,
        })
    end
end)

local RefreshResurrectionButton = RemotesTab:AddButton({
    Title = 'Refresh Player List',
    Callback = function()
        local newList = getLimboPlayers()
        ResurrectionDropdown:SetValues(newList)

        Fluent:Notify({
            Title = 'Refreshed',
            Content = 'Player list updated! Found: ' .. #newList,
            Duration = 2,
        })
    end,
})

local ResurrectButton = RemotesTab:AddButton({
    Title = 'Resurrect Player',
    Callback = function()
        if
            not selectedPlayer
            or selectedPlayer == ''
            or selectedPlayer == 'None'
        then
            Fluent:Notify({
                Title = 'Error',
                Content = 'No player selected!',
                Duration = 3,
            })
            return
        end

        local targetPlayer = playerLookup[selectedPlayer]

        if not targetPlayer or not targetPlayer.Parent then
            Fluent:Notify({
                Title = 'Error',
                Content = 'Player not found or was removed!',
                Duration = 3,
            })
            return
        end

        local success, err = pcall(function()
            local args = { selectedPlayer }
            ReplicatedStorage.Remotes.AbilityService.ToServer['AbilityActivated___']:FireServer(
                unpack(args)
            )
        end)

        if success then
            Fluent:Notify({
                Title = 'Success',
                Content = 'Resurrected ' .. selectedPlayer,
                Duration = 3,
            })
        else
            Fluent:Notify({
                Title = 'Failed',
                Content = 'Error: ' .. tostring(err),
                Duration = 4,
            })
        end
    end,
})

-- Infinite Stamina

-- Cured Notifier (Optimized - Event Driven)
MainTab:AddParagraph({
    Title = 'Cured Notifier',
    Content = 'Get notified when players are cured',
})
local curedNotifierEnabled = false
local curedNotified = {}
local curedConns = { players = {} }
local playerAddedConn, playerRemovingConn = nil, nil

local function disconnectPlayerCuredConns(p)
    local bucket = curedConns.players[p]
    if not bucket then
        return
    end
    if bucket.playerAttrConn then
        pcall(function()
            bucket.playerAttrConn:Disconnect()
        end)
        bucket.playerAttrConn = nil
    end
    if bucket.charAttrConn then
        pcall(function()
            bucket.charAttrConn:Disconnect()
        end)
        bucket.charAttrConn = nil
    end
    if bucket.charAddedConn then
        pcall(function()
            bucket.charAddedConn:Disconnect()
        end)
        bucket.charAddedConn = nil
    end
    curedConns.players[p] = nil
    curedNotified[p] = nil
end

local function handleCuredState(player)
    local function notifyIfCured()
        local isCured = false
        pcall(function()
            if player:GetAttribute('Cured') then
                isCured = true
            elseif
                player.Character and player.Character:GetAttribute('Cured')
            then
                isCured = true
            end
        end)

        if isCured and not curedNotified[player] then
            curedNotified[player] = true
            local charName
            pcall(function()
                charName = player:GetAttribute('CharacterName')
                    or (
                        player.Character
                        and player.Character:GetAttribute('CharacterName')
                    )
            end)
            charName = charName or player.Name
            Fluent:Notify({
                Title = 'ü©∫ Cured',
                Content = charName .. ' has been cured.',
                Duration = 3,
            })
        elseif not isCured and curedNotified[player] then
            curedNotified[player] = nil
        end
    end

    local bucket = curedConns.players[player]
    if not bucket then
        bucket = {}
        curedConns.players[player] = bucket

        bucket.playerAttrConn = player.AttributeChanged:Connect(function(attr)
            if attr == 'Cured' or attr == 'CharacterName' then
                notifyIfCured()
            end
        end)

        bucket.charAddedConn = player.CharacterAdded:Connect(function(char)
            if bucket.charAttrConn then
                pcall(function()
                    bucket.charAttrConn:Disconnect()
                end)
                bucket.charAttrConn = nil
            end
            if char then
                bucket.charAttrConn = char.AttributeChanged:Connect(
                    function(attr)
                        if attr == 'Cured' or attr == 'CharacterName' then
                            notifyIfCured()
                        end
                    end
                )
            end
            notifyIfCured()
        end)
    end

    if player.Character and not (bucket and bucket.charAttrConn) then
        bucket.charAttrConn = player.Character.AttributeChanged:Connect(
            function(attr)
                if attr == 'Cured' or attr == 'CharacterName' then
                    notifyIfCured()
                end
            end
        )
    end

    notifyIfCured()
end

local CuredNotifierToggle = MainTab:AddToggle('CuredNotifier', {
    Title = 'Cured Notifier',
    Default = true,
})

CuredNotifierToggle:OnChanged(function(Value)
    curedNotifierEnabled = Value
    if Value then
        if not isInitializing then
            Fluent:Notify({
                Title = 'Cured Notifier',
                Content = 'Enabled',
                Duration = 2,
            })
        end
        -- initialize for existing players
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= Players.LocalPlayer then
                handleCuredState(p)
            end
        end
        -- connect new players (idempotent)
        if not playerAddedConn then
            playerAddedConn = Players.PlayerAdded:Connect(function(p)
                if curedNotifierEnabled then
                    handleCuredState(p)
                end
            end)
        end
        if not playerRemovingConn then
            playerRemovingConn = Players.PlayerRemoving:Connect(function(p)
                disconnectPlayerCuredConns(p)
            end)
        end
    else
        if not isInitializing then
            Fluent:Notify({
                Title = 'Cured Notifier',
                Content = 'Disabled',
                Duration = 2,
            })
        end
        -- disconnect global listeners
        if playerAddedConn then
            pcall(function()
                playerAddedConn:Disconnect()
            end)
            playerAddedConn = nil
        end
        if playerRemovingConn then
            pcall(function()
                playerRemovingConn:Disconnect()
            end)
            playerRemovingConn = nil
        end
        -- disconnect all per-player listeners
        for p, _ in pairs(curedConns.players) do
            disconnectPlayerCuredConns(p)
        end
        curedNotified = {}
    end
end)

-- Infinite Stamina
MainTab:AddParagraph({
    Title = 'Infinite Stamina',
    Content = 'Never run out of stamina',
})
_G.InfiniteStaminaEnabled = false

local function runInfiniteStamina()
    while _G.InfiniteStaminaEnabled do
        local args = { false, false }
        game:GetService('ReplicatedStorage')
            :WaitForChild('Remotes')
            :WaitForChild('EnhancedMovementService')
            :WaitForChild('RunStateToggled')
            :FireServer(unpack(args))
        task.wait(0.05)
    end
end

local InfiniteStaminaToggle = MainTab:AddToggle('InfiniteStamina', {
    Title = 'Infinite Stamina',
    Default = false,
})

InfiniteStaminaToggle:OnChanged(function(Value)
    _G.InfiniteStaminaEnabled = Value
    if Value then
        if not isInitializing then
            Fluent:Notify({
                Title = 'Infinite Stamina',
                Content = 'Enabled!',
                Duration = 2,
            })
        end
        task.spawn(runInfiniteStamina)
    else
        if not isInitializing then
            Fluent:Notify({
                Title = 'Infinite Stamina',
                Content = 'Disabled',
                Duration = 2,
            })
        end
    end
end)

-- Auto Ictus
MainTab:AddParagraph({
    Title = 'Auto Ictus',
    Content = 'Automatically equip Ictus when enemy uses tracked abilities',
})

_G.AutoIctusEnabled = false
_G.AutoIctusConnections = {}

local function cleanupAutoIctus()
    -- Disconnect all Auto Ictus connections
    if _G.AutoIctusConnections then
        for _, conn in pairs(_G.AutoIctusConnections) do
            if conn and typeof(conn) == 'RBXScriptConnection' then
                pcall(function()
                    conn:Disconnect()
                end)
            end
        end
        _G.AutoIctusConnections = {}
    end
    print('[AUTO ICTUS] All connections cleaned up')
end

local function startAutoIctus()
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer
    local rs = game:GetService('ReplicatedStorage')

    local trackedAbilities = {
        ['rbxassetid://71157109677249'] = true,
        ['rbxassetid://81743171989186'] = true,
    }

    local function equipIctus()
        if not _G.AutoIctusEnabled then
            return
        end
        pcall(function()
            rs.Remotes.AbilityService.ToServer.AbilitySelected:FireServer(
                'Ictus'
            )
        end)
    end

    local function trackEnemy(player)
        if not _G.AutoIctusEnabled then
            return
        end
        if player == LocalPlayer then
            return
        end

        local function setup(char)
            if not _G.AutoIctusEnabled then
                return
            end
            local hum = char:WaitForChild('Humanoid', 5)
            if not hum then
                return
            end

            local conn = hum.AnimationPlayed:Connect(function(track)
                if not _G.AutoIctusEnabled then
                    return
                end
                local id = track.Animation and track.Animation.AnimationId
                if trackedAbilities[id] then
                    equipIctus()
                end
            end)

            -- Store connection for cleanup
            table.insert(_G.AutoIctusConnections, conn)
        end

        if player.Character then
            setup(player.Character)
        end

        local charAddedConn = player.CharacterAdded:Connect(function(char)
            if _G.AutoIctusEnabled then
                setup(char)
            end
        end)
        table.insert(_G.AutoIctusConnections, charAddedConn)
    end

    -- Track all existing players
    for _, p in ipairs(Players:GetPlayers()) do
        trackEnemy(p)
    end

    -- Track new players
    local playerAddedConn = Players.PlayerAdded:Connect(function(p)
        if _G.AutoIctusEnabled then
            trackEnemy(p)
        end
    end)
    table.insert(_G.AutoIctusConnections, playerAddedConn)
end

local AutoIctusToggle = MainTab:AddToggle('AutoIctus', {
    Title = 'Auto Ictus',
    Default = false,
})

AutoIctusToggle:OnChanged(function(Value)
    _G.AutoIctusEnabled = Value

    if Value then
        if not isInitializing then
            Fluent:Notify({
                Title = 'Auto Ictus',
                Content = 'Enabled! Will auto-equip Ictus on tracked abilities',
                Duration = 2,
            })
        end
        task.spawn(startAutoIctus)
    else
        if not isInitializing then
            Fluent:Notify({
                Title = 'Auto Ictus',
                Content = 'Disabled',
                Duration = 2,
            })
        end
        cleanupAutoIctus()
    end
end)

-- Teleportation (moved to Teleport tab)
TeleportTab:AddParagraph({
    Title = 'Teleportation',
    Content = 'Quick travel to key locations',
})

local TeleportToCureButton = TeleportTab:AddButton({
    Title = 'Teleport to Cure',
    Callback = function()
        Fluent:Notify({
            Title = 'Teleport',
            Content = 'Starting sequence...',
            Duration = 2,
        })
        local player = Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:WaitForChild('HumanoidRootPart')
        local positions = {
            Vector3.new(1113, -138, -2239),
            Vector3.new(1103, -138, -2242),
            Vector3.new(1042, -138, -2454),
        }
        local tweenInfo = TweenInfo.new(
            0.5,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.InOut,
            0,
            false,
            0
        )
        local function tweenToPosition(targetPos)
            local tween = TweenService:Create(
                hrp,
                tweenInfo,
                { CFrame = CFrame.new(targetPos) }
            )
            tween:Play()
            tween.Completed:Wait()
        end
        for i, pos in ipairs(positions) do
            tweenToPosition(pos)
            wait(0.1)
        end
        Fluent:Notify({
            Title = 'Teleport',
            Content = 'Complete!',
            Duration = 2,
        })
    end,
})

-- Teleport to Safe Area
-- Adds a new teleport button to the Teleport tab that moves the player to a predefined safe area.
local TeleportToSafeAreaButton = TeleportTab:AddButton({
    Title = 'Teleport to Safe Area',
    Callback = function()
        Fluent:Notify({
            Title = 'Teleport',
            Content = 'Starting sequence...',
            Duration = 2,
        })
        local player = Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:WaitForChild('HumanoidRootPart')
        -- Only one position for safe area teleport; wrap in table for consistency
        local positions = {
            Vector3.new(1174, 77, -730),
        }
        -- Configure tween for smooth movement
        local tweenInfo = TweenInfo.new(
            0.5,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.InOut,
            0,
            false,
            0
        )
        -- Helper to tween to a single position
        local function tweenToPosition(targetPos)
            local tween = TweenService:Create(
                hrp,
                tweenInfo,
                { CFrame = CFrame.new(targetPos) }
            )
            tween:Play()
            tween.Completed:Wait()
        end
        -- Execute the tween sequence
        for i, pos in ipairs(positions) do
            tweenToPosition(pos)
            -- slight delay between movements, kept for future extensibility
            wait(0.1)
        end
        Fluent:Notify({
            Title = 'Teleport',
            Content = 'Complete!',
            Duration = 2,
        })
    end,
})

-- Infinite Yield
MiscTab:AddParagraph({
    Title = 'Admin Commands',
    Content = 'Load admin command scripts',
})

local InfiniteYieldButton = MiscTab:AddButton({
    Title = 'Infinite Yield',
    Callback = function()
        Fluent:Notify({
            Title = 'Infinite Yield',
            Content = 'Loading...',
            Duration = 2,
        })
        loadstring(
            game:HttpGet(
                'https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'
            )
        )()
        Fluent:Notify({
            Title = 'Infinite Yield',
            Content = 'Loaded!',
            Duration = 2,
        })
    end,
})

-- Anti Annoy
MiscTab:AddParagraph({
    Title = 'Anti Annoy',
    Content = 'Remove annoying effects',
})

local AntiAnnoyButton = MiscTab:AddButton({
    Title = 'Anti Annoy',
    Callback = function()
        if not isInitializing then
            Fluent:Notify({
                Title = 'Anti Annoy',
                Content = 'Anti Annoy script executed',
                Duration = 2,
            })
        end
        loadstring(game:HttpGet('https://pastebin.com/raw/rWr3t3Sj'))()
    end,
})

-- Camera Section
MiscTab:AddParagraph({
    Title = 'Camera',
    Content = 'Camera control options',
})

-- Noclip Camera Toggle
local noclipCameraActive = false
local originalCameraMode = nil

local NoclipCameraToggle = MiscTab:AddToggle('NoclipCamera', {
    Title = 'Noclip Camera',
    Default = false,
})

NoclipCameraToggle:OnChanged(function(Value)
    noclipCameraActive = Value
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer

    if Value then
        -- Enable noclip camera (SMOOTH VERSION)
        local Camera = workspace.CurrentCamera

        -- Store original settings
        if not originalCameraMode then
            originalCameraMode = {
                cameraMode = LocalPlayer.CameraMode,
                occlusionMode = LocalPlayer.DevCameraOcclusionMode,
            }
        end

        -- Use ONLY DevCameraOcclusionMode for smooth noclip
        -- This prevents the choppy zoom caused by CameraType switching
        pcall(function()
            LocalPlayer.DevCameraOcclusionMode =
                Enum.DevCameraOcclusionMode.Invisicam
        end)

        -- Optional: Adjust zoom limits for better control
        pcall(function()
            LocalPlayer.CameraMaxZoomDistance = 400 -- Reasonable max zoom
            LocalPlayer.CameraMinZoomDistance = 0.5 -- Allow close zoom
        end)

        if not isInitializing then
            Fluent:Notify({
                Title = 'Noclip Camera',
                Content = 'Camera collision disabled',
                Duration = 2,
            })
        end
    else
        -- Disable noclip camera (restore original settings)
        if originalCameraMode then
            pcall(function()
                LocalPlayer.DevCameraOcclusionMode = originalCameraMode.occlusionMode
                    or Enum.DevCameraOcclusionMode.Zoom
            end)

            pcall(function()
                LocalPlayer.CameraMode = originalCameraMode.cameraMode
            end)

            originalCameraMode = nil
        else
            -- Fallback if no original settings stored
            pcall(function()
                LocalPlayer.DevCameraOcclusionMode =
                    Enum.DevCameraOcclusionMode.Zoom
            end)
        end

        if not isInitializing then
            Fluent:Notify({
                Title = 'Noclip Camera',
                Content = 'Camera collision enabled',
                Duration = 2,
            })
        end
    end
end)

-- üîß WEBHOOK TAB üîß
-- This tab allows the Discord webhook URL and the role ID used for staff notifications
-- to be changed on‚Äëthe‚Äëfly. A test button is also provided to send a sample
-- notification using the current settings.
local CustomTab = Window:AddTab({ Title = 'Custom', Icon = 'palette' })

CustomTab:AddParagraph({
    Title = 'Particle Controls',
    Content = 'Customize particle effects',
})

-- Color Presets
local COLOR_PRESETS = {
    ['Purple'] = { r = 128, g = 0, b = 255 },
    ['Blue'] = { r = 0, g = 100, b = 255 },
    ['Red'] = { r = 255, g = 0, b = 0 },
    ['Green'] = { r = 0, g = 255, b = 0 },
    ['Yellow'] = { r = 255, g = 255, b = 0 },
    ['Orange'] = { r = 255, g = 165, b = 0 },
    ['Pink'] = { r = 255, g = 105, b = 180 },
    ['Cyan'] = { r = 0, g = 255, b = 255 },
    ['White'] = { r = 255, g = 255, b = 255 },
    ['Black'] = { r = 0, g = 0, b = 0 },
}

-- Dynamic color variables (default to Purple)
local selectedFireCircleColor = 'Purple'

-- Current color values
local FIRE_CIRCLE_COLOR = ColorSequence.new(Color3.fromRGB(128, 0, 255))
local FIRE_CIRCLE_RGB = Color3.fromRGB(128, 0, 255)

local customFireCircleActive = false
local fireCircleConnections = {}
local fireCircleDescendantConnections = {}
local fireCircleOriginalEmitters = {}
local fireCircleOriginalLights = {}

local function updateFireCircleColor(colorName)
    local color = COLOR_PRESETS[colorName]
    if color then
        FIRE_CIRCLE_COLOR =
            ColorSequence.new(Color3.fromRGB(color.r, color.g, color.b))
        FIRE_CIRCLE_RGB = Color3.fromRGB(color.r, color.g, color.b)
        selectedFireCircleColor = colorName

        -- If hook is active, reapply colors to all existing particles
        if customFireCircleActive then
            for emitter, _ in pairs(fireCircleOriginalEmitters) do
                if emitter and emitter.Parent then
                    emitter.Color = FIRE_CIRCLE_COLOR
                end
            end
            for light, _ in pairs(fireCircleOriginalLights) do
                if light and light.Parent then
                    light.Color = FIRE_CIRCLE_RGB
                end
            end
        end

        print('[FIRE CIRCLE] Color updated to:', colorName)
    end
end

local function restoreFireCircleColors()
    for emitter, color in pairs(fireCircleOriginalEmitters) do
        if emitter and emitter.Parent then
            emitter.Color = color
        end
    end
    for light, color in pairs(fireCircleOriginalLights) do
        if light and light.Parent then
            light.Color = color
        end
    end
    table.clear(fireCircleOriginalEmitters)
    table.clear(fireCircleOriginalLights)
end

local function enableFireCircleHook()
    if customFireCircleActive then
        return
    end
    customFireCircleActive = true

    -- Throttling variables
    local lastColorChange = {}
    local COLOR_CHANGE_THROTTLE = 0.1 -- Only update every 0.1 seconds

    -- MoonSec v3 compatible approach - optimized for performance
    local function applyColorToObject(desc)
        if not customFireCircleActive or not desc.Parent then
            return
        end

        if desc:IsA('ParticleEmitter') then
            if not fireCircleOriginalEmitters[desc] then
                fireCircleOriginalEmitters[desc] = desc.Color
            end
            desc.Color = FIRE_CIRCLE_COLOR

            -- Throttled color monitoring
            local conn = desc:GetPropertyChangedSignal('Color')
                :Connect(function()
                    if not customFireCircleActive or not desc.Parent then
                        return
                    end

                    local now = tick()
                    local lastChange = lastColorChange[desc] or 0

                    if now - lastChange >= COLOR_CHANGE_THROTTLE then
                        lastColorChange[desc] = now
                        desc.Color = FIRE_CIRCLE_COLOR
                    end
                end)
            table.insert(fireCircleConnections, conn)
        elseif desc:IsA('PointLight') then
            if not fireCircleOriginalLights[desc] then
                fireCircleOriginalLights[desc] = desc.Color
            end
            desc.Color = FIRE_CIRCLE_RGB

            -- Throttled color monitoring
            local conn = desc:GetPropertyChangedSignal('Color')
                :Connect(function()
                    if not customFireCircleActive or not desc.Parent then
                        return
                    end

                    local now = tick()
                    local lastChange = lastColorChange[desc] or 0

                    if now - lastChange >= COLOR_CHANGE_THROTTLE then
                        lastColorChange[desc] = now
                        desc.Color = FIRE_CIRCLE_RGB
                    end
                end)
            table.insert(fireCircleConnections, conn)
        end
    end

    local function monitorAndColorize(instance)
        if not customFireCircleActive then
            return
        end

        -- Batch process descendants
        task.spawn(function()
            local descendants = instance:GetDescendants()
            local batchSize = 20

            for i = 1, #descendants, batchSize do
                if not customFireCircleActive then
                    break
                end

                for j = i, math.min(i + batchSize - 1, #descendants) do
                    local desc = descendants[j]
                    if
                        desc:IsA('ParticleEmitter') or desc:IsA('PointLight')
                    then
                        applyColorToObject(desc)
                    end
                end

                if i + batchSize < #descendants then
                    task.wait() -- Yield between batches
                end
            end
        end)

        -- Throttled descendant monitoring
        local pendingDescendants = {}
        local isProcessingDescendants = false

        local function processDescendants()
            if isProcessingDescendants or not customFireCircleActive then
                return
            end
            isProcessingDescendants = true

            task.spawn(function()
                while #pendingDescendants > 0 and customFireCircleActive do
                    local desc = table.remove(pendingDescendants, 1)
                    if desc and desc.Parent then
                        applyColorToObject(desc)
                    end

                    if #pendingDescendants > 5 then
                        task.wait() -- Yield if queue is large
                    end
                end
                isProcessingDescendants = false
            end)
        end

        local descConn = instance.DescendantAdded:Connect(function(desc)
            if not customFireCircleActive then
                return
            end

            if desc:IsA('ParticleEmitter') or desc:IsA('PointLight') then
                table.insert(pendingDescendants, desc)
                processDescendants()
            end
        end)
        fireCircleDescendantConnections[instance] = descConn
    end

    -- Process existing debris in background
    task.spawn(function()
        local debris = workspace.Debris:GetChildren()
        for i, child in ipairs(debris) do
            if not customFireCircleActive then
                break
            end
            monitorAndColorize(child)

            if i % 5 == 0 then
                task.wait() -- Yield every 5 items
            end
        end
    end)

    -- Monitor new debris
    fireCircleConnections.debris = workspace.Debris.ChildAdded:Connect(
        function(child)
            if customFireCircleActive then
                monitorAndColorize(child)
            end
        end
    )

    print(
        '[FIRE CIRCLE] Hook enabled with color:',
        selectedFireCircleColor,
        '(Optimized)'
    )
end

local function disableFireCircleHook()
    if not customFireCircleActive then
        return
    end
    customFireCircleActive = false

    -- Disconnect all connections
    for _, conn in pairs(fireCircleConnections) do
        if
            conn
            and typeof(conn) == 'RBXScriptConnection'
            and conn.Connected
        then
            conn:Disconnect()
        end
    end
    table.clear(fireCircleConnections)

    for inst, conn in pairs(fireCircleDescendantConnections) do
        if
            conn
            and typeof(conn) == 'RBXScriptConnection'
            and conn.Connected
        then
            conn:Disconnect()
        end
        fireCircleDescendantConnections[inst] = nil
    end

    -- Restore original colors
    restoreFireCircleColors()

    print('[FIRE CIRCLE] Hook disabled - colors restored')
end

-- Fire Circle Color Dropdown
local FireCircleColorDropdown = CustomTab:AddDropdown('FireCircleColor', {
    Title = 'Fire Circle Color',
    Values = {
        'Purple',
        'Blue',
        'Red',
        'Green',
        'Yellow',
        'Orange',
        'Pink',
        'Cyan',
        'White',
        'Black',
    },
    Multi = false,
    Default = 1,
})

FireCircleColorDropdown:OnChanged(function(Value)
    local selected = type(Value) == 'table' and Value[1] or Value
    updateFireCircleColor(selected)
    if not isInitializing then
        Fluent:Notify({
            Title = 'Fire Circle Color',
            Content = 'Color set to: ' .. selected,
            Duration = 2,
        })
    end
end)

-- Fire Circle Toggle
local FireCircleToggle = CustomTab:AddToggle('FireCircle', {
    Title = 'Enable Custom Fire Circle',
    Default = false,
})

FireCircleToggle:OnChanged(function(Value)
    if Value then
        enableFireCircleHook()
        if not isInitializing then
            Fluent:Notify({
                Title = 'Fire Circle',
                Content = 'Custom colors enabled ('
                    .. selectedFireCircleColor
                    .. ')',
                Duration = 2,
            })
        end
    else
        disableFireCircleHook()
        if not isInitializing then
            Fluent:Notify({
                Title = 'Fire Circle',
                Content = 'Custom colors disabled',
                Duration = 2,
            })
        end
    end
end)

-- ‚ö° STAFF NOTIFIER TAB ‚ö°
local StaffNotifierTab =
    Window:AddTab({ Title = 'Staff Notifier', Icon = 'shield-alert' })

StaffNotifierTab:AddParagraph({
    Title = 'Staff Notifier',
    Content = 'Get notified when staff members join the game. Fully compatible with moonsec v3 obfuscation.',
})

-- Staff notifier state
_G.STAFF_WEBHOOK_URL = _G.STAFF_WEBHOOK_URL or ''
_G.STAFF_NOTIFIER_ENABLED = true -- Automatically enabled on script execution
_G.STAFF_DETECTION_METHODS = _G.STAFF_DETECTION_METHODS
    or {
        group_check = true, -- Only method - uses groupRoles table
    }

-- Known staff user IDs (add known staff IDs here)
local KNOWN_STAFF_IDS = {
    -- Add staff user IDs here if known
}

-- HTTP request function compatible with most executors (moonsec obfuscation proof)
local function sendWebhookNotification(webhookUrl, embedData)
    if not webhookUrl or webhookUrl == '' then
        warn('[Staff Notifier] No webhook URL configured')
        return false
    end

    -- Try multiple HTTP request methods for maximum executor compatibility
    local httpRequest = (syn and syn.request)
        or (http and http.request)
        or http_request
        or (fluxus and fluxus.request)
        or request
        or (http_request and http_request)

    if not httpRequest then
        warn(
            '[Staff Notifier] HTTP request function not available in this executor'
        )
        return false
    end

    -- Use game service directly to avoid obfuscation issues
    local HttpService = game:GetService('HttpService')

    -- Sanitize fields to ensure all values are proper types
    local sanitizedFields = {}
    if embedData.fields then
        for _, field in ipairs(embedData.fields) do
            table.insert(sanitizedFields, {
                name = tostring(field.name or ''),
                value = tostring(field.value or ''),
                inline = field.inline == true,
            })
        end
    end

    local payload = HttpService:JSONEncode({
        embeds = {
            {
                title = tostring(embedData.title or 'Staff Member Detected'),
                description = tostring(
                    embedData.description
                        or 'A staff member has joined the game!'
                ),
                color = tonumber(embedData.color) or 15158332, -- Red color
                fields = sanitizedFields,
                footer = {
                    text = tostring(
                        'TVL Staff Notifier ‚Ä¢ ' .. os.date('%I:%M %p')
                    ),
                },
                timestamp = tostring(os.date('!%Y-%m-%dT%H:%M:%S') .. 'Z'),
            },
        },
    })

    local success, response = pcall(function()
        return httpRequest({
            Url = webhookUrl,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json',
            },
            Body = payload,
        })
    end)

    if
        success
        and response
        and (response.StatusCode == 204 or response.StatusCode == 200)
    then
        print('[Staff Notifier] Webhook sent successfully')
        return true
    else
        warn(
            '[Staff Notifier] Failed to send webhook:',
            response and response.StatusCode or 'Unknown error'
        )
        return false
    end
end

-- Obfuscation-proof staff detection
local function isStaffMember(player)
    local reasons = {}

    -- Method 1: Check user ID against known staff
    if table.find(KNOWN_STAFF_IDS, player.UserId) then
        table.insert(reasons, 'Known Staff ID')
        return true, reasons
    end

    -- Method 2: Check group roles (only check specific groups from groupRoles table)
    -- Uses Roblox API - works even in fully obfuscated games
    if _G.STAFF_DETECTION_METHODS.group_check then
        local success, groups = pcall(function()
            -- Use GetService to ensure proper service access in obfuscated environments
            local GroupService = game:GetService('GroupService')
            return GroupService:GetGroupsAsync(player.UserId)
        end)

        if success and groups then
            for _, group in ipairs(groups) do
                -- Only check groups defined in the groupRoles table
                local groupId = group.Id
                if groupRoles[groupId] then
                    local staffConfig = groupRoles[groupId]
                    local roleName = group.Role or ''

                    -- Check if player's role is in the staff roles list
                    if staffConfig.roles[roleName] then
                        table.insert(
                            reasons,
                            'Group Role: '
                                .. roleName
                                .. ' in '
                                .. staffConfig.name
                        )
                        return true, reasons
                    end
                end
            end
        end
    end

    -- Method 3: Check for special attributes (set by game even when obfuscated)
    if
        player:GetAttribute('IsStaff')
        or player:GetAttribute('Staff')
        or player:GetAttribute('Admin')
        or player:GetAttribute('Moderator')
    then
        table.insert(reasons, 'Staff Attribute')
        return true, reasons
    end

    return false, reasons
end

-- Notification function
local function notifyStaff(player, reasons)
    if not _G.STAFF_NOTIFIER_ENABLED then
        return
    end

    print('[Staff Notifier] Staff member detected:', player.Name)

    -- Send Discord webhook
    if _G.STAFF_WEBHOOK_URL and _G.STAFF_WEBHOOK_URL ~= '' then
        local fields = {
            {
                name = 'üë§ Player',
                value = player.Name .. ' (@' .. player.DisplayName .. ')',
                inline = true,
            },
            {
                name = 'üÜî User ID',
                value = tostring(player.UserId),
                inline = true,
            },
            {
                name = 'üìä Account Age',
                value = player.AccountAge .. ' days',
                inline = true,
            },
            {
                name = 'üéÆ Server',
                value = game.JobId,
                inline = false,
            },
        }

        if #reasons > 0 then
            table.insert(fields, {
                name = '‚ö†Ô∏è Detection Reason',
                value = table.concat(reasons, '\n'),
                inline = false,
            })
        end

        sendWebhookNotification(_G.STAFF_WEBHOOK_URL, {
            title = 'üö® STAFF MEMBER DETECTED',
            description = 'A staff member has joined your server!',
            color = 15158332,
            fields = fields,
        })
    end

    -- In-game notification
    Fluent:Notify({
        Title = 'üö® Staff Alert',
        Content = player.Name .. ' (Staff) joined the game!',
        Duration = 8,
    })

    -- Play alert sound
    local sound = Instance.new('Sound')
    sound.SoundId = 'rbxassetid://6518811702' -- Alert sound
    sound.Volume = 0.5
    sound.Parent = game:GetService('SoundService')
    sound:Play()
    task.delay(3, function()
        sound:Destroy()
    end)
end

-- Monitor players
local function setupStaffMonitor()
    -- Check existing players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            task.spawn(function()
                local isStaff, reasons = isStaffMember(player)
                if isStaff then
                    notifyStaff(player, reasons)
                end
            end)
        end
    end

    -- Monitor new players
    game.Players.PlayerAdded:Connect(function(player)
        if not _G.STAFF_NOTIFIER_ENABLED then
            return
        end

        task.wait(1) -- Wait for player data to load

        task.spawn(function()
            local isStaff, reasons = isStaffMember(player)
            if isStaff then
                notifyStaff(player, reasons)
            end
        end)
    end)
end

-- UI Elements
StaffNotifierTab:AddParagraph({
    Title = '‚öôÔ∏è Configuration',
    Content = 'Configure your staff notifier settings below',
})

-- Enable/Disable Toggle
local StaffNotifierToggle = StaffNotifierTab:AddToggle('StaffNotifier', {
    Title = 'Enable Staff Notifier',
    Description = 'Get notified when staff join',
    Default = true,
})

StaffNotifierToggle:OnChanged(function(Value)
    _G.STAFF_NOTIFIER_ENABLED = Value

    if Value then
        setupStaffMonitor()
        Fluent:Notify({
            Title = 'Staff Notifier',
            Content = 'Staff notifier enabled',
            Duration = 2,
        })
    else
        Fluent:Notify({
            Title = 'Staff Notifier',
            Content = 'Staff notifier disabled',
            Duration = 2,
        })
    end
end)

-- Webhook URL Input
local WebhookInput = StaffNotifierTab:AddInput('WebhookURL', {
    Title = 'Discord Webhook URL',
    Description = 'Paste your Discord webhook URL',
    Default = _G.STAFF_WEBHOOK_URL,
    Placeholder = 'https://discord.com/api/webhooks/...',
    Callback = function(Value)
        _G.STAFF_WEBHOOK_URL = Value
        print('[Staff Notifier] Webhook URL updated')
    end,
})

-- Test Webhook Button
StaffNotifierTab:AddButton({
    Title = 'üß™ Test Webhook',
    Description = 'Send a test notification to your webhook',
    Callback = function()
        if not _G.STAFF_WEBHOOK_URL or _G.STAFF_WEBHOOK_URL == '' then
            Fluent:Notify({
                Title = 'Test Failed',
                Content = 'Please enter a webhook URL first',
                Duration = 3,
            })
            return
        end

        -- Safely get game name with fallback
        local gameName = 'Unknown Game'
        pcall(function()
            local productInfo = game:GetService('MarketplaceService')
                :GetProductInfo(game.PlaceId)
            if productInfo and productInfo.Name then
                gameName = tostring(productInfo.Name)
            end
        end)

        local success = sendWebhookNotification(_G.STAFF_WEBHOOK_URL, {
            title = '‚úÖ Webhook Test Successful',
            description = 'Your webhook is working correctly!',
            color = 5763719, -- Green color
            fields = {
                {
                    name = 'üë§ Tested By',
                    value = tostring(game.Players.LocalPlayer.Name),
                    inline = true,
                },
                {
                    name = 'üéÆ Game',
                    value = gameName,
                    inline = true,
                },
                {
                    name = '‚è∞ Time',
                    value = tostring(os.date('%I:%M %p')),
                    inline = true,
                },
            },
        })

        if success then
            Fluent:Notify({
                Title = '‚úÖ Test Successful',
                Content = 'Webhook notification sent!',
                Duration = 3,
            })
        else
            Fluent:Notify({
                Title = '‚ùå Test Failed',
                Content = 'Failed to send webhook. Check URL and try again.',
                Duration = 3,
            })
        end
    end,
})

-- Detection Methods Section
StaffNotifierTab:AddParagraph({
    Title = 'üîç Detection Methods',
    Content = 'Configure how staff members are detected',
})

StaffNotifierTab:AddParagraph({
    Title = '‚ÑπÔ∏è Group Configuration',
    Content = "Group detection uses the groupRoles table (line 278). Edit that table to add your game's staff group and roles.",
})

-- Detection method toggles
local GroupCheckToggle = StaffNotifierTab:AddToggle('GroupCheck', {
    Title = 'Group Role Detection',
    Description = 'Check player group roles for staff indicators',
    Default = true,
})

GroupCheckToggle:OnChanged(function(Value)
    _G.STAFF_DETECTION_METHODS.group_check = Value
end)

-- Scan Current Players Button
StaffNotifierTab:AddButton({
    Title = 'üîÑ Scan Current Players',
    Description = 'Check all players in the server for staff',
    Callback = function()
        if not _G.STAFF_NOTIFIER_ENABLED then
            Fluent:Notify({
                Title = 'Staff Notifier Disabled',
                Content = 'Enable the staff notifier first',
                Duration = 3,
            })
            return
        end

        local staffFound = 0
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                task.spawn(function()
                    local isStaff, reasons = isStaffMember(player)
                    if isStaff then
                        staffFound = staffFound + 1
                        notifyStaff(player, reasons)
                    end
                end)
            end
        end

        task.wait(1)
        Fluent:Notify({
            Title = 'Scan Complete',
            Content = staffFound > 0
                    and (staffFound .. ' staff member(s) found')
                or 'No staff members detected',
            Duration = 3,
        })
    end,
})

-- Auto-start monitoring if enabled
if _G.STAFF_NOTIFIER_ENABLED then
    task.defer(setupStaffMonitor)
end

-- ‚öôÔ∏è SETTINGS TAB ‚öôÔ∏è
local SettingsTab = Window:AddTab({ Title = 'Settings', Icon = 'settings' })

SettingsTab:AddParagraph({
    Title = '‚öôÔ∏è Settings',
    Content = 'Customize your interface appearance and keybinds',
})

-- Setup InterfaceManager for theme and keybind
InterfaceManager:SetLibrary(Fluent)
InterfaceManager:SetFolder('TVL2Script')

-- Build Interface section (Theme + Minimize Keybind)
InterfaceManager:BuildInterfaceSection(SettingsTab)

-- Select Main tab on startup
task.defer(function()
    task.wait(0.1)
    -- Try to select Main tab by finding it
    for i, tab in pairs(Window.Tabs) do
        if tab.Title == 'Main' then
            Window:SelectTab(i)
            break
        end
    end

    -- Mark initialization complete immediately after tab selection
    task.wait(0.1)
    isInitializing = false
    print('[SCRIPT] ‚úÖ GUI initialization complete!')
end)
